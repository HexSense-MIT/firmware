/*
 * ADS131M04.c
 *
 *  Created on: Jul 21, 2025
 *      Author: liufangzheng
 */

#include "ADS131M04.h"

static uint16_t calcCRC(const uint8_t dataBytes[], uint8_t byteCount);
static uint16_t calcCRCWithInitVal(const uint8_t dataBytes[], uint8_t byteCount, uint16_t initVal);
static int32_t signExtend(const uint8_t *dataBytes);
static uint8_t spiTransmitReceiveByte(uint8_t tx);
static void spiTransmitReceiveBytes(const uint8_t txBytes[], uint8_t rxBytes[], uint8_t byteCount);
static void delay_us(uint32_t us);
static int32_t twoscom(int32_t value);

// make sure you defined the LORA_SPI_HANDLE in main.h
extern SPI_HandleTypeDef ADS131M04_SPI_HANDLE;

const uint16_t ADS_ZEROS_16 = 0x0000;
const uint8_t  ADS_ZEROS_8  = 0x00;

void ADS_CS_LOW(void) {
  HAL_GPIO_WritePin(GPIOC, ADS_CS_Pin, GPIO_PIN_RESET);
}

void ADS_CS_HIGH(void) {
  HAL_GPIO_WritePin(GPIOC, ADS_CS_Pin, GPIO_PIN_SET);
}

static void spiTransmitReceiveBytes(const uint8_t txBytes[], uint8_t rxBytes[], uint8_t byteCount) {
  HAL_SPI_TransmitReceive(&hspi1, txBytes, rxBytes, byteCount, 0xFFFF);
}

uint16_t ADS131M04_TransmitCommand(const uint16_t opcode) {
  #ifdef ADS131M04_ENABLE_CRC
  uint8_t wordCount = 2;
  #else
  uint8_t wordCount = 1;
  #endif
  uint8_t byteCount = wordCount * ADS131M04_WORD_LENGTH;

  uint8_t txBytes[byteCount];
  uint8_t rxBytes[byteCount];
  memset(txBytes, 0, byteCount*sizeof(uint8_t));
  memset(rxBytes, 0, byteCount*sizeof(uint8_t));

  txBytes[0] = (uint8_t)(opcode >> 8);
  txBytes[1] = (uint8_t)(opcode & 0xFF);

  #ifdef ADS131M04_ENABLE_CRC
  uint16_t crc = calcCRC(txBytes, 2 * ADS131M04_WORD_LENGTH);
  txBytes[ADS131M04_WORD_LENGTH] = (uint8_t)(crc >> 8);
  txBytes[ADS131M04_WORD_LENGTH + 1] = (uint8_t)(crc & 0xFF);
  #endif

  spiTransmitReceiveBytes(txBytes, rxBytes, byteCount);

  return (rxBytes[0] << 8) | rxBytes[1];
}

void ADS131M04_TransmitFrame(const uint16_t opcodes[], uint8_t opcodeCount) {
  #ifdef ADS131M04_ENABLE_CRC
  uint8_t wordCount = opcodeCount + 1;
  #else
  uint8_t wordCount = opcodeCount;
  #endif
  uint8_t byteCount = wordCount * ADS131M04_WORD_LENGTH;

  uint8_t txBytes[byteCount];
  uint8_t rxBytes[byteCount];
  memset(txBytes, 0, byteCount*sizeof(uint8_t));
  memset(rxBytes, 0, byteCount*sizeof(uint8_t));

  uint8_t i;

  for (i = 0; i < opcodeCount; i++) {
    txBytes[i * ADS131M04_WORD_LENGTH] = (uint8_t)(opcodes[i] >> 8);
    txBytes[i * ADS131M04_WORD_LENGTH + 1] = (uint8_t)(opcodes[i] & 0xFF);
  }

  #ifdef ADS131M04_ENABLE_CRC
  uint16_t crc = calcCRC(txBytes, (opcodeCount + 1) * ADS131M04_WORD_LENGTH);
  txBytes[i * ADS131M04_WORD_LENGTH] = (uint8_t)(crc >> 8);
  txBytes[i * ADS131M04_WORD_LENGTH + 1] = (uint8_t)(crc & 0xFF);
  #endif

  spiTransmitReceiveBytes(txBytes, rxBytes, byteCount);
}

uint16_t ADS131M04_TransmitWord16(const uint16_t opcode) {
  uint8_t byteCount = ADS131M04_WORD_LENGTH;

  uint8_t txBytes[byteCount];
  uint8_t rxBytes[byteCount];
  memset(txBytes, 0, byteCount*sizeof(uint8_t));
  memset(rxBytes, 0, byteCount*sizeof(uint8_t));

  txBytes[0] = (uint8_t)(opcode >> 8);
  txBytes[1] = (uint8_t)(opcode & 0xFF);

  spiTransmitReceiveBytes(txBytes, rxBytes, byteCount);

  return (rxBytes[0] << 8) | rxBytes[1];
}

uint16_t ADS131M04_ReadRegister(uint8_t addr) {
  uint16_t data;
  uint16_t opcode = ADS131M04_OPCODE_RREG | (addr << 7);

  ADS131M04_TransmitCommand(opcode);
  
  ADS131M04_TransmitCommand(ADS131M04_OPCODE_NULL);
  ADS131M04_TransmitCommand(ADS131M04_OPCODE_NULL); // dummy

  data = ADS131M04_TransmitCommand(ADS131M04_OPCODE_NULL);

  ADS131M04_TransmitCommand(ADS131M04_OPCODE_NULL);
  ADS131M04_TransmitCommand(ADS131M04_OPCODE_NULL);

  return data;
}

void ADS131M04_WriteRegister(uint8_t addr, uint16_t value) {
  uint16_t opcodes[2];
  opcodes[0] = ADS131M04_OPCODE_WREG | (addr << 7);
  opcodes[1] = value;

  ADS131M04_TransmitFrame(opcodes, 2);
  
  for(uint8_t i = 0; i < 9; i++) ADS131M04_TransmitWord16(ADS131M04_OPCODE_NULL);
  
  ADS131M04_ReadRegister(addr); // Read back to verify write
}

void ADS131M04_writeRegisterMasked(uint8_t address, uint16_t value, uint16_t mask) {
  uint16_t register_contents = ADS131M04_ReadRegister(address);
  register_contents = register_contents & ~mask;
  register_contents = register_contents | value;
  ADS131M04_WriteRegister(address, register_contents);
}

void ADS131M04_Init(void) {
  HAL_Delay(50); // Wait for power-up
}

int8_t ADS131M04_isDataReadySoft(byte channel) {
  if (channel == 0) {
    return (readRegister(REG_STATUS) & REGMASK_STATUS_DRDY0);
  }
  else if (channel == 1) {
    return (readRegister(REG_STATUS) & REGMASK_STATUS_DRDY1);
  }
  else if (channel == 2) {
    return (readRegister(REG_STATUS) & REGMASK_STATUS_DRDY2);
  }
  else if (channel == 3) {
    return (readRegister(REG_STATUS) & REGMASK_STATUS_DRDY3);
  }
  else {
    return -1;
  }
}

bool ADS131M04_isResetStatus(void)
{
  return (readRegister(REG_STATUS) & REGMASK_STATUS_RESET);
}

bool ADS131M04_isLockSPI(void)
{
  return (readRegister(REG_STATUS) & REGMASK_STATUS_LOCK);
}

bool ADS131M04_setDrdyFormat(uint8_t drdyFormat)
{
  if (drdyFormat > 1)
  {
    return false;
  }
  else
  {
    writeRegisterMasked(REG_MODE, drdyFormat, REGMASK_MODE_DRDY_FMT);
    return true;
  }
}

bool ADS131M04_setDrdyStateWhenUnavailable(uint8_t drdyState)
{
  if (drdyState > 1)
  {
    return false;
  }
  else
  {
    writeRegisterMasked(REG_MODE, drdyState < 1, REGMASK_MODE_DRDY_HiZ);
    return true;
  }
}

bool ADS131M04_setPowerMode(uint8_t powerMode)
{
  if (powerMode > 3)
  {
    return false;
  }
  else
  {
    writeRegisterMasked(REG_CLOCK, powerMode, REGMASK_CLOCK_PWR);
    return true;
  }
}

bool ADS131M04_setOsr(uint16_t osr)
{
  if (osr > 7)
  {
    return false;
  }
  else
  {
    writeRegisterMasked(REG_CLOCK, osr << 2 , REGMASK_CLOCK_OSR);
    return true;
  }
}

bool ADS131M04_setChannelEnable(uint8_t channel, uint16_t enable)
{
  if (channel > 3)
  {
    return false;
  }
  if (channel == 0)
  {
    writeRegisterMasked(REG_CLOCK, enable << 8, REGMASK_CLOCK_CH0_EN);
    return true;
  }
  else if (channel == 1)
  {
    writeRegisterMasked(REG_CLOCK, enable << 9, REGMASK_CLOCK_CH1_EN);
    return true;
  }
  else if (channel == 2)
  {
    writeRegisterMasked(REG_CLOCK, enable << 10, REGMASK_CLOCK_CH2_EN);
    return true;
  }
  else if (channel == 3)
  {
    writeRegisterMasked(REG_CLOCK, enable << 11, REGMASK_CLOCK_CH3_EN);
    return true;
  }
}

bool ADS131M04_setChannelPGA(uint8_t channel, uint16_t pga)
{
  if (channel > 3)
  {
    return false;
  }
  if (channel == 0)
  {
    writeRegisterMasked(REG_GAIN, pga, REGMASK_GAIN_PGAGAIN0);
    return true;
  }
  else if (channel == 1)
  {
    writeRegisterMasked(REG_GAIN, pga << 4, REGMASK_GAIN_PGAGAIN1);
    return true;
  }
  else if (channel == 2)
  {
    writeRegisterMasked(REG_GAIN, pga << 8, REGMASK_GAIN_PGAGAIN2);
    return true;
  }
  else if (channel == 3)
  {
    writeRegisterMasked(REG_GAIN, pga << 12, REGMASK_GAIN_PGAGAIN3);
    return true;
  }
}

void ADS131M04_setGlobalChop(uint16_t global_chop)
{
  writeRegisterMasked(REG_CFG, global_chop << 8, REGMASK_CFG_GC_EN);
}

void ADS131M04_setGlobalChopDelay(uint16_t delay)
{
  writeRegisterMasked(REG_CFG, delay << 9, REGMASK_CFG_GC_DLY);
}

bool ADS131M04_setInputChannelSelection(uint8_t channel, uint8_t input)
{
  if (channel > 3)
  {
    return false;
  }
  if (channel == 0)
  {
    writeRegisterMasked(REG_CH0_CFG, input, REGMASK_CHX_CFG_MUX);
    return true;
  }
  else if (channel == 1)
  {
    writeRegisterMasked(REG_CH1_CFG, input, REGMASK_CHX_CFG_MUX);
    return true;
  }
  else if (channel == 2)
  {
    writeRegisterMasked(REG_CH2_CFG, input, REGMASK_CHX_CFG_MUX);
    return true;
  }
  else if (channel == 3)
  {
    writeRegisterMasked(REG_CH3_CFG, input, REGMASK_CHX_CFG_MUX);
    return true;
  }
}

bool ADS131M04_setChannelOffsetCalibration(uint8_t channel, int32_t offset)
{

  uint16_t MSB = offset >> 8;
  uint8_t LSB = offset;

  if (channel > 3)
  {
    return false;
  }
  if (channel == 0)
  {
    writeRegisterMasked(REG_CH0_OCAL_MSB, MSB, 0xFFFF);
    writeRegisterMasked(REG_CH0_OCAL_LSB, LSB << 8, REGMASK_CHX_OCAL0_LSB);
    return true;
  }
  else if (channel == 1)
  {
    writeRegisterMasked(REG_CH1_OCAL_MSB, MSB, 0xFFFF);
    writeRegisterMasked(REG_CH1_OCAL_LSB, LSB << 8, REGMASK_CHX_OCAL0_LSB);
    return true;
  }
  else if (channel == 2)
  {
    writeRegisterMasked(REG_CH2_OCAL_MSB, MSB, 0xFFFF);
    writeRegisterMasked(REG_CH2_OCAL_LSB, LSB << 8, REGMASK_CHX_OCAL0_LSB);
    return true;
  }
  else if (channel == 3)
  {
    writeRegisterMasked(REG_CH3_OCAL_MSB, MSB, 0xFFFF);
    writeRegisterMasked(REG_CH3_OCAL_LSB, LSB << 8 , REGMASK_CHX_OCAL0_LSB);
    return true;
  }
}

bool ADS131M04_setChannelGainCalibration(uint8_t channel, uint32_t gain) {
  uint16_t MSB = gain >> 8;
  uint8_t LSB = gain;

  if (channel > 3)
  {
    return false;
  }
  if (channel == 0)
  {
    writeRegisterMasked(REG_CH0_GCAL_MSB, MSB, 0xFFFF);
    writeRegisterMasked(REG_CH0_GCAL_LSB, LSB << 8, REGMASK_CHX_GCAL0_LSB);
    return true;
  }
  else if (channel == 1)
  {
    writeRegisterMasked(REG_CH1_GCAL_MSB, MSB, 0xFFFF);
    writeRegisterMasked(REG_CH1_GCAL_LSB, LSB << 8, REGMASK_CHX_GCAL0_LSB);
    return true;
  }
  else if (channel == 2)
  {
    writeRegisterMasked(REG_CH2_GCAL_MSB, MSB, 0xFFFF);
    writeRegisterMasked(REG_CH2_GCAL_LSB, LSB << 8, REGMASK_CHX_GCAL0_LSB);
    return true;
  }
  else if (channel == 3)
  {
    writeRegisterMasked(REG_CH3_GCAL_MSB, MSB, 0xFFFF);
    writeRegisterMasked(REG_CH3_GCAL_LSB, LSB << 8, REGMASK_CHX_GCAL0_LSB);
    return true;
  }
}

bool ADS131M04_isDataReady() {
  if (digitalRead(ADS131M04_DRDY_PIN) == HIGH)
  {
    return false;
  }
  return true;
}

adcOutput ADS131M04_readADC(void) {
  uint8_t x = 0;
  uint8_t x2 = 0;
  uint8_t x3 = 0;
  int32_t aux;
  adcOutput res;

  digitalWrite(ADS131M04_CS_PIN, LOW);
  delayMicroseconds(1);

  x = SPI.transfer(0x00);
  x2 = SPI.transfer(0x00);
  SPI.transfer(0x00);

  res.status = ((x << 8) | x2);

  x = SPI.transfer(0x00);
  x2 = SPI.transfer(0x00);
  x3 = SPI.transfer(0x00);

  aux = (((x << 16) | (x2 << 8) | x3) & 0x00FFFFFF);
  if (aux > 0x7FFFFF)
  {
    res.ch0 = ((~(aux)&0x00FFFFFF) + 1) * -1;
  }
  else
  {
    res.ch0 = aux;
  }

  x = SPI.transfer(0x00);
  x2 = SPI.transfer(0x00);
  x3 = SPI.transfer(0x00);

  aux = (((x << 16) | (x2 << 8) | x3) & 0x00FFFFFF);
  if (aux > 0x7FFFFF)
  {
    res.ch1 = ((~(aux)&0x00FFFFFF) + 1) * -1;
  }
  else
  {
    res.ch1 = aux;
  }

  x = SPI.transfer(0x00);
  x2 = SPI.transfer(0x00);
  x3 = SPI.transfer(0x00);

  aux = (((x << 16) | (x2 << 8) | x3) & 0x00FFFFFF);
  if (aux > 0x7FFFFF)
  {
    res.ch2 = ((~(aux)&0x00FFFFFF) + 1) * -1;
  }
  else
  {
    res.ch2 = aux;
  }

  x = SPI.transfer(0x00);
  x2 = SPI.transfer(0x00);
  x3 = SPI.transfer(0x00);

  aux = (((x << 16) | (x2 << 8) | x3) & 0x00FFFFFF);
  if (aux > 0x7FFFFF)
  {
    res.ch3 = ((~(aux)&0x00FFFFFF) + 1) * -1;
  }
  else
  {
    res.ch3 = aux;
  }
  SPI.transfer(0x00);
  SPI.transfer(0x00);
  SPI.transfer(0x00);

  delayMicroseconds(1);
  digitalWrite(ADS131M04_CS_PIN, HIGH);

  return res;
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
  UNUSED(GPIO_Pin); // Prevent unused variable warning

  if (GPIO_Pin == ADS_DRDY_Pin) {
  }
}

static void delay_us(uint32_t us) {
  uint32_t startTicks = SysTick->VAL;
  uint32_t tick = HAL_GetTick();
  uint32_t delayTicks = us * (SystemCoreClock / 1000000);
  if(startTicks < delayTicks) {
    while(HAL_GetTick() == tick);
    while((SystemCoreClock / 1000) + startTicks - delayTicks < SysTick->VAL);
  } else {
    while (HAL_GetTick() == tick && startTicks - delayTicks < SysTick->VAL);
  }
}

static int32_t twoscom(int32_t value) {
  if (value > 0x7FFFFF) {
    return ((~(value) & 0x00FFFFFF) + 1) * -1;
  }
  return value;
}