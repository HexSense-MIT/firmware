/*
 * DW3000_FZ.c
 *
 *  Created on: Jul 16, 2025
 *      Author: liufangzheng
 */

#include "DW3000_FZ.h"

bool DW3000_IRQ_flag = false; // flag to indicate if the TX is done

// remember put this in the main.h: #define LORA_SPI_HANDLE hspi1
extern SPI_HandleTypeDef UWB_SPI_HANDLE;

unsigned int countBits(unsigned int number) {
  unsigned int count = 0;
  while (number) {
    count++;
    number >>= 1; // Right shift the number by 1 bit
  }
  return count;
}

HAL_StatusTypeDef sendBytes(uint8_t *sendb, uint16_t sendLen) {
  HAL_StatusTypeDef status = HAL_OK;

  status = HAL_SPI_Transmit(&UWB_SPI_HANDLE, sendb, sendLen, 1);

  return status;
}

HAL_StatusTypeDef readBytes(uint8_t *recvb, uint16_t recLen) {
  HAL_StatusTypeDef status = HAL_OK;

  HAL_SPI_Receive(&UWB_SPI_HANDLE, recvb, recLen, 1);

  return status;
}

uint8_t DW3000pack_fast_command(uint8_t cmd) {
  uint8_t b = 0x81;
  b |= ((cmd & 0x1F) << 1);

  return b;
}

// uint8_t address: 5-bit short address
// uint8_t rw: 1-bit read/write
uint8_t DW3000pack_short_address(uint8_t address, uint8_t rw) {
  uint8_t b = 0x00;
  b |= (rw << 7);
  b |= ((address & 0x1F) << 1);

  return b;
}

uint16_t DW3000pack_full_address(uint8_t base, uint8_t sub, uint8_t rw) {
  uint16_t header = 0x4000;

  header |= (rw << 15);
  header |= ((base & 0x1F) << 9);
  header |= ((sub & 0x7F) << 2);

  return header;
}

void DW3000pack_mask_cmd_1octet(uint32_t reg, uint8_t andmask, uint8_t ormask, uint8_t* cmd) {
  uint8_t base = reg >> 16;
  uint8_t sub  = reg & 0xFF;

  uint16_t header = 0xC001;

  header |= ((base & 0x1F) << 9);
  header |= ((sub & 0x7F) << 2);

  cmd[0] = header >> 8;
  cmd[1] = header & 0xFF;
  cmd[2] = andmask;
  cmd[3] = ormask;
}

void DW3000pack_mask_cmd_2octet(uint32_t reg, uint16_t andmask, uint16_t ormask, uint8_t* cmd) {
  uint8_t base = reg >> 16;
  uint8_t sub  = reg & 0xFF;

  uint16_t header = 0xC002;

  header |= ((base & 0x1F) << 9);
  header |= ((sub & 0x7F) << 2);

  cmd[0] = header >> 8;
  cmd[1] = header & 0xFF;
  cmd[2] = andmask & 0xFF;
  cmd[3] = andmask >> 8;
  cmd[4] = ormask & 0xFF;
  cmd[5] = ormask >> 8;
}

void DW3000pack_mask_cmd_4octet(uint32_t reg, uint32_t andmask, uint32_t ormask, uint8_t* cmd) {
  uint8_t base = reg >> 16;
  uint8_t sub  = reg & 0xFF;

  uint16_t header = 0xC003;

  header |= ((base & 0x1F) << 9);
  header |= ((sub & 0x7F) << 2);

  cmd[0] = header >> 8;
  cmd[1] = header & 0xFF;
  cmd[2] = andmask & 0xFF;
  cmd[3] = andmask >> 8;
  cmd[4] = andmask >> 16;
  cmd[5] = andmask >> 24;
  cmd[6] = ormask & 0xFF;
  cmd[7] = ormask >> 8;
  cmd[8] = ormask >> 16;
  cmd[9] = ormask >> 24;
}

void set_bits(uint32_t reg, uint32_t mask, uint8_t reg_width) {
  // longest command is 10 bytes, so allocate 10 bytes
  uint8_t cmd[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  uint32_t andmask = 0xFFFFFFFFUL;
  uint32_t ormask  = mask;

  if (reg_width == 1)      DW3000pack_mask_cmd_1octet(reg, andmask, ormask, cmd);
  else if (reg_width == 2) DW3000pack_mask_cmd_2octet(reg, andmask, ormask, cmd);
  else if (reg_width == 4) DW3000pack_mask_cmd_4octet(reg, andmask, ormask, cmd);

  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_RESET);
  sendBytes(cmd, 10);
  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_SET);
}

void reset_bits(uint32_t reg, uint32_t mask, uint8_t reg_width) {
  // longest command is 10 bytes, so allocate 10 bytes
  uint8_t cmd[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  uint32_t andmask = ~mask; // reset bits
  uint32_t ormask  = 0x0UL; // keep the same

  if (reg_width == 1)      DW3000pack_mask_cmd_1octet(reg, andmask, ormask, cmd);
  else if (reg_width == 2) DW3000pack_mask_cmd_2octet(reg, andmask, ormask, cmd);
  else if (reg_width == 4) DW3000pack_mask_cmd_4octet(reg, andmask, ormask, cmd);

  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_RESET);
  sendBytes(cmd, 10);
  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_SET);
}

/**
 * @brief Set the SPI speed to low speed (5 MHz)
 * 
 * @param hspi 
 */
void set_SPI2lowspeed(SPI_HandleTypeDef *hspi) {
  // set SPI speed to 3 MHz
  hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;

  if (HAL_SPI_Init(hspi) != HAL_OK) {
    Error_Handler();
  }
}

/**
 * @brief set the SPI speed to high speed (20 MHz)
 * 
 * @param hspi 
 */
void set_SPI2highspeed(SPI_HandleTypeDef *hspi) {
  // set SPI speed to 24 MHz
  hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;

  if (HAL_SPI_Init(hspi) != HAL_OK) {
    Error_Handler();
  }
}

/**
 * @brief Enable on the DW3000 3.3V LDO
 * 
 */
void DW3000poweron(void) {
  HAL_GPIO_WritePin(UWB_PWR_EN_GPIO_Port, UWB_PWR_EN_Pin, GPIO_PIN_SET);
}

/**
 * @brief Set the DW3000 SPI to low speed (5MHz)
 * 
 * @param hspi 
 */
void DW3000init(SPI_HandleTypeDef *hspi) {
  set_SPI2lowspeed(hspi);
}

/**
 * @brief Reset the DW3000.
 * The RSTn pin can also be used to reset the device.
 * Host microprocessor can use this pin to reset the device instead of calling dwt_softreset() function.
 * The pin should be driven low (for 10 ns) and then left in open-drain mode.
 * RSTn pin should never be driven high.
 * 
 */
void DW3000hardReset(void) {
  HAL_GPIO_WritePin(UWB_RST_GPIO_Port, UWB_RST_Pin, GPIO_PIN_RESET);
  HAL_Delay(10);
  HAL_GPIO_WritePin(UWB_RST_GPIO_Port, UWB_RST_Pin, GPIO_PIN_SET);
}

/**
 * @brief Write data to a register on the DW3000
 * 
 * @param reg register full address (base + sub)
 * @param data data to write
 * @param len length of data to write (1, 2, 4 bytes)
 */
void DW3000writereg(uint32_t reg, uint8_t* data, uint8_t len) {
  uint8_t base = reg >> 16;
  uint8_t sub  = reg & 0xFF;

  uint16_t header = DW3000pack_full_address(base, sub, 1);

  // uint8_t* regBytes = data;
  uint8_t headerBytes[2];
  headerBytes[0] = (header >> 8) & 0xFF;
  headerBytes[1] = header & 0xFF;

  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_RESET);
  sendBytes(headerBytes, 2);
  sendBytes(data, len);
  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_SET);
}

/**
 * @brief Read data from a register on the DW3000
 * 
 * @param reg register full address (base + sub)
 * @param len length of data to read (1, 2, 4 bytes)
 * @return uint32_t data read from the register
 */
uint32_t DW3000readreg(uint32_t reg, uint8_t len) {
  uint8_t base = reg >> 16;
  uint8_t sub  = reg & 0xFF;

  uint16_t header = DW3000pack_full_address(base, sub, 0);

  uint8_t regBytes[4] = {0, 0, 0, 0};
  uint8_t headerBytes[2];
  headerBytes[0] = (header >> 8) & 0xFF;
  headerBytes[1] = header & 0xFF;

  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_RESET);
  sendBytes(headerBytes, 2);
  readBytes(regBytes, len);
  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_SET);

  // Combine the 4 bytes into a single 32-bit integer
  uint32_t regValue =
  ((uint32_t)regBytes[3] << 24) |
  ((uint32_t)regBytes[2] << 16) |
  ((uint32_t)regBytes[1] << 8)  |
  ((uint32_t)regBytes[0]);

  return regValue;
}

/**
 * @brief set the AINIT2IDLE bit in the SEQ_CTRL register to automatically enter the IDLE_PLL state
 * 
 */
void DW3000enter_IDLE_PLL(void) {
  set_bits(SEQ_CTRL_ID, SEQ_CTRL_AINIT2IDLE_BIT_MASK, 4); // set the AINIT2IDLE bit
  Delay_us(10);
}

/**
 * @brief FZ stole from DecaWave API, check if the DW3000 is in the IDLE_RC state
 * 
 * @return uint8_t 
 */
uint8_t DW3000check_IDLE_RC(void) {
  uint32_t reg = DW3000readreg(SYS_STATUS_ID, 4);
  return ((reg & (SYS_STATUS_RCINIT_BIT_MASK)) == (SYS_STATUS_RCINIT_BIT_MASK));
}

/**
 * @brief check if the DW3000 PLL locked, which shows the DW3000 is in the IDLE_PLL state
 * 
 * @return uint8_t 
 */
uint8_t DW3000check_IDLE_PLL(void) {
  uint32_t reg = DW3000readreg(SYS_STATUS_ID, 4);
  return ((reg & (SYS_STATUS_CP_LOCK_BIT_MASK)) == (SYS_STATUS_CP_LOCK_BIT_MASK)) ? 1U : 0U;
}

/**
 * @brief check if the DW3000 is in the IDLE_PLL state
 * 
 * @return uint8_t 
 */
uint8_t DW3000check_IDLE(void) {
  uint32_t reg = DW3000readreg(SYS_STATE_LO_ID, 4);
  return (reg >> 16 & DW_SYS_STATE_IDLE) == DW_SYS_STATE_IDLE ? 1 : 0;
}

void enable_LED_blink(void) {
  uint32_t current_ctrl = DW3000readreg(LED_CTRL_ID, 4);
  current_ctrl |= (1 << LED_CTRL_BLINK_EN_BIT_OFFSET);
  DW3000writereg(LED_CTRL_ID, (uint8_t*)&current_ctrl, 4);
}

/**
 * @brief Set the DW3000 TXLED pin
 * 
 */
void DW3000set_TXLED(void) {
  enable_LED_blink();

  uint32_t current_mode;

  current_mode = DW3000readreg(GPIO_MODE_ID, 4);
  current_mode &= ~GPIO_MODE_MSGP3_MODE_BIT_MASK; // Clear the bits
  current_mode |= (0x01 << GPIO_MODE_MSGP3_MODE_BIT_OFFSET); // Set the TXLED mode bit

  DW3000writereg(GPIO_MODE_ID, (uint8_t*)&current_mode, 4);
}

/**
 * @brief read DW3000 OTP memory
 * 
 * @param addr OTP address
 * @return uint32_t OTP data
 */
uint32_t DW3000readOTP(uint8_t addr) {
  uint8_t address = addr;
  uint8_t const_02 = 0x02;
  DW3000writereg(OTP_ADDR_ID, &address, 2);
  DW3000writereg(OTP_CFG_ID, &const_02, 2);

  uint32_t reg = DW3000readreg(OTP_RDATA_ID, 4);

  return reg;
}

/**
 * @brief write a fast command to the DW3000
 * 
 * @param cmd 
 */
void DW3000_writefastCMD_FZ(uint8_t cmd) {
  uint8_t cmd2send = DW3000pack_fast_command(cmd);

  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_RESET);
  sendBytes(&cmd2send, 1);
  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_SET);
}

// clear the IRQ flags
void DW3000_clear_IRQ(void) {
  uint32_t irqFlags = DW3000readreg(SYS_STATUS_ID, 4);
    // FZ: Clear the interrupt flags
  DW3000writereg(SYS_STATUS_ID, (uint8_t*)&irqFlags, 4);
  DW3000_IRQ_flag = false;
}

void DW3000_clear_all_events(void) {
  DW3000_writefastCMD_FZ(CMD_CLR_IRQS);
}

void DW3000config_CH(uint16_t RX_PCODE, uint16_t TX_PCODE, uint8_t SFD_TYP, channel CH) {
  uint32_t chan_ctrl = 0;

  chan_ctrl |= ((RX_PCODE << CHAN_CTRL_RX_PCODE_BIT_OFFSET) & CHAN_CTRL_RX_PCODE_BIT_MASK) |
               ((TX_PCODE << CHAN_CTRL_TX_PCODE_BIT_OFFSET) & CHAN_CTRL_TX_PCODE_BIT_MASK) |
               ((SFD_TYP  << CHAN_CTRL_SFD_TYPE_BIT_OFFSET) & CHAN_CTRL_SFD_TYPE_BIT_MASK) |
               ((CH       << CHAN_CTRL_RF_CHAN_BIT_OFFSET) & CHAN_CTRL_RF_CHAN_BIT_MASK);

  // FZ: write the channel control register
  DW3000writereg(CHAN_CTRL_ID, (uint8_t*)&chan_ctrl, 4);
}

void DW3000_irq_for_tx_done(void) {
  uint32_t sys_enable = DW3000readreg(SYS_ENABLE_LO_ID, 4);
  sys_enable |= (1 << SYS_ENABLE_LO_TXFRS_ENABLE_BIT_OFFSET); // Enable TX done interrupt
  DW3000writereg(SYS_ENABLE_LO_ID, (uint8_t*)&sys_enable, SYS_ENABLE_LO_LEN);
}

void DW3000_irq_for_rx_done(void) {
  // uint32_t sys_enable = DW3000readreg(SYS_ENABLE_LO_ID, 4);
  // sys_enable |= ((1 << SYS_ENABLE_LO_RXFR_ENABLE_BIT_OFFSET)  |
  //                (1 << SYS_ENABLE_LO_RXPHD_ENABLE_BIT_OFFSET)); // Enable RX done interrupt
  uint32_t sys_enable = SYS_ENABLE_LO_MASK;
  DW3000writereg(SYS_ENABLE_LO_ID, (uint8_t*)&sys_enable, SYS_ENABLE_LO_LEN);
}

void DW3000_disable_RX_timeout(void) {
  ;
}

void DW3000_set_max_sfd_timeout(void) {
  // FZ: Set the maximum SFD timeout
  uint16_t sfd_timeout = RX_SFD_TOC_MASK;
  DW3000writereg(RX_SFD_TOC_ID, (uint8_t*)&sfd_timeout, 2);
}

void DW3000_debug_reg(uint32_t reg, uint8_t len) {
  uint32_t reg_value = DW3000readreg(reg, len);
  printf("DW3000 Register 0x%08lX: 0x%08lX\r\n", reg, reg_value);
}

/**
 * @brief FZ: from: https://gist.github.com/egnor/455d510e11c22deafdec14b09da5bf54
 * Things which are actually documented but easy to miss
 * - If using a 16MHz PRF (PCODE 3 or 4), set RX_TUNE_EN in DGC_CFG
 * - Always change THR_64 in DGC_CFG to 0x32
 * - Always clear DT0B4 in DTUNE0
 * - Always change COMP_DLY in RX_CAL to 0x2
 * - Always change LDO_RLOAD to 0x14
 * - Always change RF_TX_CTRL_1 to 0x0E
 * - Always change RF_TX_CTRL_2 to 0x1C071134 (ch5) or 0x1C010034 (ch9)
 * - Always change PLL_CFG to 0x1F3C (ch5) or 0x0F3C (ch9)
 * - Always change PLL_CFG_LD in PLL_CAL to 0x8 (documented as 0x81 but that's the whole register)
 */
void DW3000_cfg_FZ(void) {
  // Always change THR_64 in DGC_CFG to 0x32
  uint32_t dgc_cfg = DW3000readreg(DGC_CFG_ID, 4);
  dgc_cfg |= (1 << DGC_CFG_RX_TUNE_EN_BIT_OFFSET) |
             (0x32 << DGC_CFG_THR_64_BIT_OFFSET); // Enable RX tuning
  DW3000writereg(DGC_CFG_ID, (uint8_t*)&dgc_cfg, 4);

  // Always clear DT0B4 in DTUNE0
  uint32_t dtune0 = DW3000readreg(DTUNE0_ID, 4);
  dtune0 &= ~DTUNE0_DT0B4_BIT_MASK; // Clear the DT0B4 bit
  DW3000writereg(DTUNE0_ID, (uint8_t*)&dtune0, 4);

  // Always change COMP_DLY in RX_CAL to 0x2
  uint32_t rx_cal = DW3000readreg(RX_CAL_CFG_ID, 4);
  rx_cal &= ~RX_CAL_CFG_COMP_DLY_BIT_MASK; // Clear the COMP_DLY
  rx_cal |= (0x2 << RX_CAL_CFG_COMP_DLY_BIT_OFFSET); // Set COMP_DLY to 0x2
  DW3000writereg(RX_CAL_CFG_ID, (uint8_t*)&rx_cal, 4);

  // Always change LDO_RLOAD to 0x14
  uint8_t ldo_cfg = 0x14; // LDO_RLOAD value
  DW3000writereg(LDO_RLOAD_ID, &ldo_cfg, 1);

  // Always change RF_TX_CTRL_1 to 0x0E
  uint8_t rf_tx_ctrl_1 = 0x0E;
  DW3000writereg(RF_TX_CTRL_1_ID, &rf_tx_ctrl_1, 1);

  // Always change RF_TX_CTRL_2 to 0x1C071134 (ch5) or 0x1C010034 (ch9)
  uint32_t channel_ctrl = DW3000readreg(CHAN_CTRL_ID, 4);
  uint32_t channel_sel  = channel_ctrl & CHAN_CTRL_RF_CHAN_BIT_MASK; // Get the current channel
  uint32_t rf_tx_ctrl_2 = (channel_sel == 0) ? 0x1C071134 : 0x1C010034; // Set RF_TX_CTRL_2 based on channel
  DW3000writereg(TX_CTRL_HI_ID, (uint8_t*)&rf_tx_ctrl_2, 4);

  // Always change PLL_CFG to 0x1F3C (ch5) or 0x0F3C (ch9)
  uint16_t pll_cfg = (channel_sel == 0) ? 0x1F3C : 0x0F3C; // Set PLL_CFG based on channel
  DW3000writereg(PLL_CFG_ID, (uint8_t*)&pll_cfg, 2);

  // Always change PLL_CFG_LD in PLL_CAL to 0x8
  uint32_t pll_cal = DW3000readreg(PLL_CAL_ID, 4);
  pll_cal &= ~PLL_CAL_PLL_PLL_CFG_LD_MASK; // Clear the PLL_CFG_LD bits
  pll_cal |= (0x8 << PLL_CAL_PLL_PLL_CFG_LD_OFFSET); // Set PLL_CFG_LD to 0x8
  DW3000writereg(PLL_CAL_ID, (uint8_t*)&pll_cal, 4);
}

/**
 * @brief from: https://gist.github.com/egnor/455d510e11c22deafdec14b09da5bf54
 * Receiver calibration (aka "PGF calibration") must run successfully at startup
 * (and after wakeup or 20Â°C temperature change) for decent performance.
 * The manual describes how to start calibration with RX_CAL and check results
 * in RX_CAL_RESI and RX_CAL_RESQ but misses some details:
 * - Before running calibration, bits 0 (VDDMS1), 2 (VDDMS3), and 8 (VDDIF2) must be set in LDO_CTRL
 * - Before reading RX_CAL_RESI/RESQ, bit 16 in RX_CAL_CFG (the low bit of COMP_DLY) must be set
 * - (After calibration, the previous value of LDO_CTRL should be restored to save power.)
 * - Without these steps, calibration will fail (missing LDOs) and the failure won't be noticed
 *   (result values not being read properly), but the radio will perform very badly.
 */
void DW3000_pgf_cal(void) {
  // pre calibration steps
  uint32_t ldo_ctrl = DW3000readreg(LDO_CTRL_ID, 4);
  uint32_t ldo_ctrl_restore = ldo_ctrl; // Save the original LDO_CTRL value

  // Set VDDMS1, VDDMS3, and VDDIF2 bits in LDO_CTRL
  ldo_ctrl |= (1 << LDO_CTRL_LDO_VDDMS1_EN_BIT_OFFSET) |
              (1 << LDO_CTRL_LDO_VDDMS3_EN_BIT_OFFSET) |
              (1 << LDO_CTRL_LDO_VDDIF2_EN_BIT_OFFSET);
  DW3000writereg(LDO_CTRL_ID, (uint8_t*)&ldo_ctrl, 4);

  // calibration steps
  uint32_t rx_cal_cfg = DW3000readreg(RX_CAL_CFG_ID, 4);
  rx_cal_cfg &= ~RX_CAL_CFG_CAL_MODE_BIT_MASK; // Set the CAL_MODE to 0
  rx_cal_cfg |= (0x01 << RX_CAL_CFG_CAL_MODE_BIT_OFFSET); // set CAL_MODE to calibration mode
  DW3000writereg(RX_CAL_CFG_ID, (uint8_t*)&rx_cal_cfg, 4);
  // Start the calibration
  rx_cal_cfg = DW3000readreg(RX_CAL_CFG_ID, 4);
  rx_cal_cfg |= (0x01 << RX_CAL_CFG_CAL_EN_BIT_OFFSET);
  DW3000writereg(RX_CAL_CFG_ID, (uint8_t*)&rx_cal_cfg, 4);

  // Wait for calibration to complete
  while (!(DW3000readreg(RX_CAL_STS_ID, 1) & 0x01)) {
    HAL_Delay(1); // Delay to avoid busy-waiting
  }

  // back to normal mode
  rx_cal_cfg = DW3000readreg(RX_CAL_CFG_ID, 4);
  rx_cal_cfg &= ~RX_CAL_CFG_CAL_MODE_BIT_MASK; // Set the CAL_MODE to 0
  DW3000writereg(RX_CAL_CFG_ID, (uint8_t*)&rx_cal_cfg, 4);

  // LDO back to restored value to save power
  DW3000writereg(LDO_CTRL_ID, (uint8_t*)&ldo_ctrl_restore, 4);
}

// FZ: the IRQ will be triggered at the very beginning because
// the SPI ready will cause an interrupt
// so we need to clear the interrupt
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
  UNUSED(GPIO_Pin); // Prevent unused variable warning

  if (GPIO_Pin == UWB_IRQ_Pin) {
    DW3000_IRQ_flag = true;
  }
}



// ----------------------------------- FZ: stole from DecaWave API (Jul 18, 2025) -----------------------------------
// Macros and Enumerations for SPI & CLock blocks
//
#define DW3000_SPI_FAC      (0<<6 | 1<<0)
#define DW3000_SPI_FARW     (0<<6 | 0<<0)
#define DW3000_SPI_EAMRW    (1<<6)

typedef struct
{
    uint32_t      partID ;            // IC Part ID - read during initialisation
    uint32_t      lotID ;             // IC Lot ID - read during initialisation
    uint8_t       bias_tune;          // bias tune code
    uint8_t       dgc_otp_set;        // Flag to check if DGC values are programmed in OTP
    uint8_t       vBatP;              // IC V bat read during production and stored in OTP (Vmeas @ 3V3)
    uint8_t       tempP;              // IC temp read during production and stored in OTP (Tmeas @ 23C)
    uint8_t       longFrames ;        // Flag in non-standard long frame mode
    uint8_t       otprev ;            // OTP revision number (read during initialisation)
    uint8_t       init_xtrim;         // initial XTAL trim value read from OTP (or defaulted to mid-range if OTP not programmed)
    uint8_t       dblbuffon;          // Double RX buffer mode and DB status flag
    uint16_t      sleep_mode;         // Used for automatic reloading of LDO tune and microcode at wake-up
    uint16_t       ststhreshold;       // Threshold for deciding if received STS is good or bad
    dwt_spi_crc_mode_e   spicrc;      // Use SPI CRC when this flag is true
    uint8_t       stsconfig;          // STS configuration mode
    uint8_t       cia_diagnostic;     // CIA dignostic logging level
    dwt_cb_data_t cbData;             // Callback data structure
    dwt_spierrcb_t cbSPIRDErr;        // Callback for SPI read error events
    dwt_cb_t    cbTxDone;             // Callback for TX confirmation event
    dwt_cb_t    cbRxOk;               // Callback for RX good frame event
    dwt_cb_t    cbRxTo;               // Callback for RX timeout events
    dwt_cb_t    cbRxErr;              // Callback for RX error events
    dwt_cb_t    cbSPIErr;             // Callback for SPI error events
    dwt_cb_t    cbSPIRdy;             // Callback for SPI ready events
} localdata;

static localdata _ptr;
static localdata *pdw3000local = &_ptr;

int writetospi(uint16_t headerLength, uint8_t *headerBuffer, uint16_t bodyLength, uint8_t *bodyBuffer)
{
  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_RESET);
  sendBytes(headerBuffer, headerLength);
  sendBytes(bodyBuffer, bodyLength);
  // for(int i = 0; i < headerLength; i++) {
  //   SPI.transfer(headerBuffer[i]); // send header
  // }
  // for(int i = 0; i < bodyLength; i++) {
  //   SPI.transfer(bodyBuffer[i]); // write values
  // }
  // delayMicroseconds(5);
  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_SET);

  return 0;
}

int readfromspi(uint16_t headerLength, uint8_t *headerBuffer, uint16_t readLength, uint8_t *readBuffer)
{
  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_RESET);
  sendBytes(headerBuffer, headerLength);
  readBytes(readBuffer, readLength);
  // for(int i = 0; i < headerLength; i++) {
  //   SPI.transfer(headerBuffer[i]); // send header
  // }
  // for(int i = 0; i < readLength; i++) {
  //   readBuffer[i] = SPI.transfer(JUNK); // read values
  // }
  // delayMicroseconds(5);
  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_SET);

  return 0;
}

/*! ------------------------------------------------------------------------------------------------------------------
* @brief  this function is used to read/write to the DW3000 device registers
*
* input parameters:
* @param recordNumber  - ID of register file or buffer being accessed
* @param index         - byte index into register file or buffer being accessed
* @param length        - number of bytes being written
* @param buffer        - pointer to buffer containing the 'length' bytes to be written
* @param rw            - DW3000_SPI_WR_BIT/DW3000_SPI_RD_BIT
*
* no return value
*/
static void dwt_xfer3000
(
  uint32_t    regFileID,  //0x0, 0x04-0x7F ; 0x10000, 0x10004, 0x10008-0x1007F; 0x20000 etc
  uint16_t    indx,       //sub-index, calculated from regFileID 0..0x7F,
  uint16_t    length,
  uint8_t     *buffer,
  spi_modes_e mode
)
{
  uint8_t  header[2];           // Buffer to compose header in
  uint16_t cnt = 0;             // Counter for length of a header

  uint16_t reg_file     = 0x1F & ((regFileID + indx) >> 16);
  uint16_t reg_offset   = 0x7F &  (regFileID + indx);

  assert(reg_file     <= 0x1F);
  assert(reg_offset   <= 0x7F);
  assert(length       < 0x3100);
  assert(mode == DW3000_SPI_WR_BIT ||\
         mode == DW3000_SPI_RD_BIT ||\
         mode == DW3000_SPI_AND_OR_8 ||\
         mode == DW3000_SPI_AND_OR_16 ||\
         mode == DW3000_SPI_AND_OR_32);

  // Write message header selecting WRITE operation and addresses as appropriate
  uint16_t  addr;
  addr = (reg_file << 9) | (reg_offset << 2);

  header[0] = (uint8_t)((mode | addr) >> 8);   //  & 0xFF; //bit7 + addr[4:0] + sub_addr[6:6]
  header[1] = (uint8_t)(addr | (mode & 0x03)); // & 0xFF; //EAM: subaddr[5:0]+ R/W/AND_OR

  if (/*reg_offset == 0 && */length == 0) {   /* Fast Access Commands (FAC)
        * only write operation is possible for this mode
        * bit_7=one is W operation, bit_6=zero: FastAccess command, bit_[5..1] addr, bits_0=one: MODE of FastAccess
        */
      assert(mode == DW3000_SPI_WR_BIT);

      header[0] = (uint8_t)((DW3000_SPI_WR_BIT>>8) | (regFileID<<1) | DW3000_SPI_FAC);
      cnt = 1;
  }
  else if (reg_offset == 0 /*&& length > 0*/ && (mode == DW3000_SPI_WR_BIT || mode == DW3000_SPI_RD_BIT))
  {   /* Fast Access Commands with Read/Write support (FACRW)
        * bit_7 is R/W operation, bit_6=zero: FastAccess command, bit_[5..1] addr, bits_0=zero: MODE of FastAccess
        */
      header[0] |= DW3000_SPI_FARW;
      cnt = 1;
  }
  else
  {  /* Extended Address Mode with Read/Write support (EAMRW)
      * b[0] = bit_7 is R/W operation, bit_6 one = ExtendedAddressMode;
      * b[1] = addr<<2 | (mode&0x3)
      */
    header[0] |= DW3000_SPI_EAMRW;
    cnt = 2;
  }

  switch (mode)
  {
    case    DW3000_SPI_AND_OR_8:
    case    DW3000_SPI_AND_OR_16:
    case    DW3000_SPI_AND_OR_32:
    case    DW3000_SPI_WR_BIT:
    {
      {
        writetospi(cnt, header, length, buffer);
      }
      break;
    }

    case DW3000_SPI_RD_BIT:
    {
      readfromspi(cnt, header, length, buffer);
      break;
    }

    default:
      while(1);
      break;
  }
} // end dwt_xfer3000()

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to write to the DW3000 device registers
 *
 * input parameters:
 * @param recordNumber  - ID of register file or buffer being accessed
 * @param index         - byte index into register file or buffer being accessed
 * @param length        - number of bytes being written
 * @param buffer        - pointer to buffer containing the 'length' bytes to be written
 *
 * output parameters
 *
 * no return value
 */
//static
void dwt_writetodevice(uint32_t regFileID, uint16_t index, uint16_t length, uint8_t *buffer) {
  dwt_xfer3000(regFileID, index, length, buffer, DW3000_SPI_WR_BIT);
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to read from the DW3000 device registers
 *
 * @param recordNumber  - ID of register file or buffer being accessed
 * @param index         - byte index into register file or buffer being accessed
 * @param length        - number of bytes being read
 * @param buffer        - pointer to buffer in which to return the read data.
 *
 * output parameters
 *
 * no return value
 */
//static
void dwt_readfromdevice
(
  uint32_t  regFileID,
  uint16_t  index,
  uint16_t  length,
  uint8_t   *buffer
)
{
  dwt_xfer3000(regFileID, index, length, buffer, DW3000_SPI_RD_BIT);
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to read 32-bit value from the DW3000 device registers
 *
 * input parameters:
 * @param regFileID - ID of register file or buffer being accessed
 * @param regOffset - the index into register file or buffer being accessed
 *
 * output parameters
 *
 * returns 32 bit register value
 */
uint32_t dwt_read32bitoffsetreg(uint32_t regFileID, uint16_t regOffset)
{
    int     j ;
    uint32_t  regval = 0 ;
    uint8_t   buffer[4] ;

    dwt_readfromdevice(regFileID,regOffset,4,buffer); // Read 4 bytes (32-bits) register into buffer

    for (j = 3 ; j >= 0 ; j --)
    {
        regval = (regval << 8) + buffer[j] ;
    }

    return (regval);

} // end dwt_read32bitoffsetreg()

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to read 16-bit value from the DW3000 device registers
 *
 * input parameters:
 * @param regFileID - ID of register file or buffer being accessed
 * @param regOffset - the index into register file or buffer being accessed
 *
 * output parameters
 *
 * returns 16 bit register value
 */
uint16_t dwt_read16bitoffsetreg(uint32_t regFileID, uint16_t regOffset)
{
    uint16_t  regval = 0 ;
    uint8_t   buffer[2] ;

    dwt_readfromdevice(regFileID,regOffset,2,buffer); // Read 2 bytes (16-bits) register into buffer

    regval = ((uint16_t)buffer[1] << 8) + buffer[0] ;
    return regval ;

} // end dwt_read16bitoffsetreg()

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to read an 8-bit value from the DW3000 device registers
 *
 * input parameters:
 * @param regFileID - ID of register file or buffer being accessed
 * @param regOffset - the index into register file or buffer being accessed
 *
 * output parameters
 *
 * returns 8-bit register value
 */
uint8_t dwt_read8bitoffsetreg(uint32_t regFileID, uint16_t regOffset)
{
    uint8_t regval;
  uint8_t buffer[1];

    dwt_readfromdevice(regFileID, regOffset, 1, buffer);
  regval = buffer[0] ;

    return regval ;
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to write 32-bit value to the DW3000 device registers
 *
 * input parameters:
 * @param regFileID - ID of register file or buffer being accessed
 * @param regOffset - the index into register file or buffer being accessed
 * @param regval    - the value to write
 *
 * output parameters
 *
 * no return value
 */
void dwt_write32bitoffsetreg(uint32_t regFileID, uint16_t regOffset, uint32_t regval)
{
    int     j ;
    uint8_t   buffer[4] ;

    for ( j = 0 ; j < 4 ; j++ )
    {
        buffer[j] = (uint8_t)regval;
        regval >>= 8 ;
    }

    dwt_writetodevice(regFileID,regOffset,4,buffer);
} // end dwt_write32bitoffsetreg()

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to write 16-bit value to the DW3000 device registers
 *
 * input parameters:
 * @param regFileID - ID of register file or buffer being accessed
 * @param regOffset - the index into register file or buffer being accessed
 * @param regval    - the value to write
 *
 * output parameters
 *
 * no return value
 */
void dwt_write16bitoffsetreg(uint32_t regFileID, uint16_t regOffset, uint16_t regval)
{
    uint8_t   buffer[2] ;

    buffer[0] = (uint8_t)regval;
    buffer[1] = regval >> 8 ;

    dwt_writetodevice(regFileID,regOffset,2,buffer);
} // end dwt_write16bitoffsetreg()

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to write an 8-bit value to the DW3000 device registers
 *
 * input parameters:
 * @param regFileID - ID of register file or buffer being accessed
 * @param regOffset - the index into register file or buffer being accessed
 * @param regval    - the value to write
 *
 * output parameters
 *
 * no return value
 */
void dwt_write8bitoffsetreg(uint32_t regFileID, uint16_t regOffset, uint8_t regval)
{
    uint8_t   buffer[1];
    buffer[0] = regval;
    dwt_writetodevice(regFileID, regOffset, 1, buffer);
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to modify a 32-bit value to the DW3000 device registers
 *
 * input parameters:
 * @param regFileID :   ID of register file or buffer being accessed
 * @param regOffset :   the index into register file or buffer being accessed
 * @param regval_and:   the value to AND to register
 * @param regval_or :   the value to OR to register
 * @output          :   no return value
 */
void dwt_modify32bitoffsetreg(const uint32_t regFileID, const uint16_t regOffset, const uint32_t _and, const uint32_t _or)
{
    uint8_t buf[8];
    buf[0] = (uint8_t)_and;//       &0xFF;
    buf[1] = (uint8_t)(_and>>8);//  &0xFF;
    buf[2] = (uint8_t)(_and>>16);// &0xFF;
    buf[3] = (uint8_t)(_and>>24);// &0xFF;
    buf[4] = (uint8_t)_or;//        &0xFF;
    buf[5] = (uint8_t)(_or>>8);//   &0xFF;
    buf[6] = (uint8_t)(_or>>16);//  &0xFF;
    buf[7] = (uint8_t)(_or>>24);//  &0xFF;
    dwt_xfer3000(regFileID, regOffset, sizeof(buf), buf, DW3000_SPI_AND_OR_32);
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to modify a 16-bit value to the DW3000 device registers
 *
 * input parameters:
 * @param regFileID :   ID of register file or buffer being accessed
 * @param regOffset :   the index into register file or buffer being accessed
 * @param regval_and:   the value to AND to register
 * @param regval_or :   the value to OR to register
 * @output          :   no return value
 */
void dwt_modify16bitoffsetreg(const uint32_t regFileID, const uint16_t regOffset, const uint16_t _and, const uint16_t _or)
{
    uint8_t buf[4];
    buf[0] = (uint8_t)_and;//       &0xFF;
    buf[1] = (uint8_t)(_and>>8);//  &0xFF;
    buf[2] = (uint8_t)_or;//        &0xFF;
    buf[3] = (uint8_t)(_or>>8);//   &0xFF;
    dwt_xfer3000(regFileID, regOffset, sizeof(buf), buf, DW3000_SPI_AND_OR_16);
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to modify a 8-bit value to the DW3000 device registers
 *
 * input parameters:
 * @param regFileID :   ID of register file or buffer being accessed
 * @param regOffset :   the index into register file or buffer being accessed
 * @param regval_and:   the value to AND to register
 * @param regval_or :   the value to OR to register
 * @output          :   no return value
 */
void dwt_modify8bitoffsetreg(const uint32_t regFileID, const uint16_t regOffset, const uint8_t _and, const uint8_t _or)
{
    uint8_t buf[2];
    buf[0] = _and;
    buf[1] = _or;
    dwt_xfer3000(regFileID, regOffset, sizeof(buf),buf, DW3000_SPI_AND_OR_8);
}

void DW3000_clearaonconfig(void) {
  // Clear any AON auto download bits (as reset will trigger AON download)
  dwt_write16bitoffsetreg(AON_DIG_CFG_ID, 0, 0x00);
  // Clear the wake-up configuration
  dwt_write8bitoffsetreg(ANA_CFG_ID, 0, 0x00);
  // Upload the new configuration
  // Copy config to AON - upload the new configuration
  dwt_write8bitoffsetreg(AON_CTRL_ID, 0, 0);
  dwt_write8bitoffsetreg(AON_CTRL_ID, 0, AON_CTRL_ARRAY_SAVE_BIT_MASK);
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief this function resets the DW3000
 *
 * NOTE: SPI rate must be <= 7MHz before a call to this function as the device will use FOSC/4 as part of internal reset
 *
 */
void DW3000softReset(void) {
  //clear any AON configurations (this will leave the device at FOSC/4, thus we need low SPI rate)
  DW3000_clearaonconfig();

  //make sure the new AON array config has been set
  HAL_Delay(1);

  //need to make sure clock is not PLL as the PLL will be switched off as part of reset
  dwt_or8bitoffsetreg(CLK_CTRL_ID, 0, FORCE_SYSCLK_FOSC);

  // Reset HIF, TX, RX and PMSC
  dwt_write8bitoffsetreg(SOFT_RST_ID, 0, DWT_RESET_ALL);

  // DW3000 needs a 10us sleep to let clk PLL lock after reset - the PLL will automatically lock after the reset
  // Could also have polled the PLL lock flag, but then the SPI needs to be <= 7MHz !! So a simple delay is easier
  HAL_Delay(1);

  //reset buffer to process RX_BUFFER_0 next - if in double buffer mode (clear bit 1 if set)
  pdw3000local->dblbuffon = DBL_BUFF_ACCESS_BUFFER_0;
  pdw3000local->sleep_mode = 0;
}
