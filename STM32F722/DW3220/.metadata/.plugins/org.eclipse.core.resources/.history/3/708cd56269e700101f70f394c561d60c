/*
 * DW3000_FZ.c
 *
 *  Created on: Dec 29, 2025
 *      Author: liufangzheng
 */


#include "DW3000_FZ.h"

// dwt_readpdoa defines
#define B12_SIGN_EXTEND_TEST (0x2000UL)
#define B12_SIGN_EXTEND_MASK (0xC000UL)

bool DW3000_IRQ_flag = false; // flag to indicate if the TX is done

// remember put this in the main.h: #define LORA_SPI_HANDLE hspi1
extern SPI_HandleTypeDef UWB_SPI_HANDLE;

unsigned int countBits(unsigned int number) {
  unsigned int count = 0;
  while (number) {
    count++;
    number >>= 1; // Right shift the number by 1 bit
  }
  return count;
}

HAL_StatusTypeDef sendBytes(uint8_t *sendb, uint16_t sendLen) {
  HAL_StatusTypeDef status = HAL_OK;

  status = HAL_SPI_Transmit(&UWB_SPI_HANDLE, sendb, sendLen, 1);

  return status;
}

HAL_StatusTypeDef readBytes(uint8_t *recvb, uint16_t recLen) {
  HAL_StatusTypeDef status = HAL_OK;

  HAL_SPI_Receive(&UWB_SPI_HANDLE, recvb, recLen, 1);

  return status;
}

uint8_t DW3000pack_fast_command(uint8_t cmd) {
  uint8_t b = 0x81;
  b |= ((cmd & 0x1F) << 1);

  return b;
}

// uint8_t address: 5-bit short address
// uint8_t rw: 1-bit read/write
uint8_t DW3000pack_short_address(uint8_t address, uint8_t rw) {
  uint8_t b = 0x00;
  b |= (rw << 7);
  b |= ((address & 0x1F) << 1);

  return b;
}

uint16_t DW3000pack_full_address(uint8_t base, uint8_t sub, uint8_t rw) {
  uint16_t header = 0x4000;

  header |= (rw << 15);
  header |= ((base & 0x1F) << 9);
  header |= ((sub & 0x7F) << 2);

  return header;
}

void DW3000pack_mask_cmd_1octet(uint32_t reg, uint8_t andmask, uint8_t ormask, uint8_t* cmd) {
  uint8_t base = reg >> 16;
  uint8_t sub  = reg & 0xFF;

  uint16_t header = 0xC001;

  header |= ((base & 0x1F) << 9);
  header |= ((sub & 0x7F) << 2);

  cmd[0] = header >> 8;
  cmd[1] = header & 0xFF;
  cmd[2] = andmask;
  cmd[3] = ormask;
}

void DW3000pack_mask_cmd_2octet(uint32_t reg, uint16_t andmask, uint16_t ormask, uint8_t* cmd) {
  uint8_t base = reg >> 16;
  uint8_t sub  = reg & 0xFF;

  uint16_t header = 0xC002;

  header |= ((base & 0x1F) << 9);
  header |= ((sub & 0x7F) << 2);

  cmd[0] = header >> 8;
  cmd[1] = header & 0xFF;
  cmd[2] = andmask & 0xFF;
  cmd[3] = andmask >> 8;
  cmd[4] = ormask & 0xFF;
  cmd[5] = ormask >> 8;
}

void DW3000pack_mask_cmd_4octet(uint32_t reg, uint32_t andmask, uint32_t ormask, uint8_t* cmd) {
  uint8_t base = reg >> 16;
  uint8_t sub  = reg & 0xFF;

  uint16_t header = 0xC003;

  header |= ((base & 0x1F) << 9);
  header |= ((sub & 0x7F) << 2);

  cmd[0] = header >> 8;
  cmd[1] = header & 0xFF;
  cmd[2] = andmask & 0xFF;
  cmd[3] = andmask >> 8;
  cmd[4] = andmask >> 16;
  cmd[5] = andmask >> 24;
  cmd[6] = ormask & 0xFF;
  cmd[7] = ormask >> 8;
  cmd[8] = ormask >> 16;
  cmd[9] = ormask >> 24;
}

void set_bits(uint32_t reg, uint32_t mask, uint8_t reg_width) {
  // longest command is 10 bytes, so allocate 10 bytes
  uint8_t cmd[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  uint32_t andmask = 0xFFFFFFFFUL;
  uint32_t ormask  = mask;

  if (reg_width == 1)      DW3000pack_mask_cmd_1octet(reg, andmask, ormask, cmd);
  else if (reg_width == 2) DW3000pack_mask_cmd_2octet(reg, andmask, ormask, cmd);
  else if (reg_width == 4) DW3000pack_mask_cmd_4octet(reg, andmask, ormask, cmd);

  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_RESET);
  sendBytes(cmd, 10);
  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_SET);
}

void reset_bits(uint32_t reg, uint32_t mask, uint8_t reg_width) {
  // longest command is 10 bytes, so allocate 10 bytes
  uint8_t cmd[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  uint32_t andmask = ~mask; // reset bits
  uint32_t ormask  = 0x0UL; // keep the same

  if (reg_width == 1)      DW3000pack_mask_cmd_1octet(reg, andmask, ormask, cmd);
  else if (reg_width == 2) DW3000pack_mask_cmd_2octet(reg, andmask, ormask, cmd);
  else if (reg_width == 4) DW3000pack_mask_cmd_4octet(reg, andmask, ormask, cmd);

  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_RESET);
  sendBytes(cmd, 10);
  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_SET);
}

/**
 * @brief Set the SPI speed to low speed (5 MHz)
 *
 * @param hspi
 */
void set_SPI2lowspeed(SPI_HandleTypeDef *hspi) {
  // set SPI speed to 3 MHz
  hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;

  if (HAL_SPI_Init(hspi) != HAL_OK) {
    Error_Handler();
  }
}

/**
 * @brief set the SPI speed to high speed (20 MHz)
 *
 * @param hspi
 */
void set_SPI2highspeed(SPI_HandleTypeDef *hspi) {
  // set SPI speed to 24 MHz
  hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;

  if (HAL_SPI_Init(hspi) != HAL_OK) {
    Error_Handler();
  }
}

/**
 * @brief Enable on the DW3000 3.3V LDO
 *
 */
void DW3000poweron(void) {
  HAL_GPIO_WritePin(UWB_PWR_EN_GPIO_Port, UWB_PWR_EN_Pin, GPIO_PIN_SET);
}

/**
 * @brief Set the DW3000 SPI to low speed (5MHz)
 *
 * @param hspi
 */
void DW3000init(SPI_HandleTypeDef *hspi) {
  set_SPI2lowspeed(hspi);
}

/**
 * @brief Reset the DW3000.
 * The RSTn pin can also be used to reset the device.
 * Host microprocessor can use this pin to reset the device instead of calling dwt_softreset() function.
 * The pin should be driven low (for 10 ns) and then left in open-drain mode.
 * RSTn pin should never be driven high.
 *
 */
void DW3000hardReset(void) {
  HAL_GPIO_WritePin(UWB_RST_GPIO_Port, UWB_RST_Pin, GPIO_PIN_RESET);
  HAL_Delay(10);
  HAL_GPIO_WritePin(UWB_RST_GPIO_Port, UWB_RST_Pin, GPIO_PIN_SET);
}

/**
 * @brief Write data to a register on the DW3000
 *
 * @param reg register full address (base + sub)
 * @param data data to write
 * @param len length of data to write (1, 2, 4 bytes)
 */
void DW3000writereg(uint32_t reg, uint8_t* data, uint8_t len) {
  uint8_t base = reg >> 16;
  uint8_t sub  = reg & 0xFF;

  uint16_t header = DW3000pack_full_address(base, sub, 1);

  // uint8_t* regBytes = data;
  uint8_t headerBytes[2];
  headerBytes[0] = (header >> 8) & 0xFF;
  headerBytes[1] = header & 0xFF;

  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_RESET);
  sendBytes(headerBytes, 2);
  sendBytes(data, len);
  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_SET);
}

/**
 * @brief Read data from a register on the DW3000
 *
 * @param reg register full address (base + sub)
 * @param len length of data to read (1, 2, 4 bytes)
 * @return uint32_t data read from the register
 */
uint32_t DW3000readreg(uint32_t reg, uint8_t len) {
  uint8_t base = reg >> 16;
  uint8_t sub  = reg & 0xFF;

  uint16_t header = DW3000pack_full_address(base, sub, 0);

  uint8_t regBytes[4] = {0, 0, 0, 0};
  uint8_t headerBytes[2];
  headerBytes[0] = (header >> 8) & 0xFF;
  headerBytes[1] = header & 0xFF;

  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_RESET);
  sendBytes(headerBytes, 2);
  readBytes(regBytes, len);
  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_SET);

  // Combine the 4 bytes into a single 32-bit integer
  uint32_t regValue =
  ((uint32_t)regBytes[3] << 24) |
  ((uint32_t)regBytes[2] << 16) |
  ((uint32_t)regBytes[1] << 8)  |
  ((uint32_t)regBytes[0]);

  return regValue;
}

/**
 * @brief set the AINIT2IDLE bit in the SEQ_CTRL register to automatically enter the IDLE_PLL state
 *
 */
void DW3000enter_IDLE_PLL(void) {
  set_bits(SEQ_CTRL_ID, SEQ_CTRL_AINIT2IDLE_BIT_MASK, 4); // set the AINIT2IDLE bit
  Delay_us(10);
}

/**
 * @brief FZ stole from DecaWave API, check if the DW3000 is in the IDLE_RC state
 *
 * @return uint8_t
 */
uint8_t DW3000check_IDLE_RC(void) {
  uint32_t reg = dwt_read32bitoffsetreg(SYS_STATUS_ID, 0);
  return ((reg & (SYS_STATUS_RCINIT_BIT_MASK)) == (SYS_STATUS_RCINIT_BIT_MASK));
}

/*! ------------------------------------------------------------------------------------------------------------------
* @brief this function clears the AON configuration in DW3000
*
* input parameters:
*
* output parameters
*
* no return value
*/
void dwt_clearaonconfig(void) {
  // Clear any AON auto download bits (as reset will trigger AON download)
  dwt_write16bitoffsetreg(AON_DIG_CFG_ID, 0, 0x00);
  // Clear the wake-up configuration
  dwt_write8bitoffsetreg(ANA_CFG_ID, 0, 0x00);
  // Upload the new configuration
  // Copy config to AON - upload the new configuration
  dwt_write8bitoffsetreg(AON_CTRL_ID, 0, 0);
  dwt_write8bitoffsetreg(AON_CTRL_ID, 0, AON_CTRL_ARRAY_SAVE_BIT_MASK);
}

/**
 * @brief check if the DW3000 PLL locked, which shows the DW3000 is in the IDLE_PLL state
 *
 * @return uint8_t
 */
uint8_t DW3000check_IDLE_PLL(void) {
  uint32_t reg = DW3000readreg(SYS_STATUS_ID, 4);
  return ((reg & (SYS_STATUS_CP_LOCK_BIT_MASK)) == (SYS_STATUS_CP_LOCK_BIT_MASK)) ? 1U : 0U;
}

/**
 * @brief check if the DW3000 is in the IDLE_PLL state
 *
 * @return uint8_t
 */
uint8_t DW3000check_IDLE(void) {
  uint32_t reg = DW3000readreg(SYS_STATE_LO_ID, 4);
  return (reg >> 16 & DW_SYS_STATE_IDLE) == DW_SYS_STATE_IDLE ? 1 : 0;
}

void enable_LED_blink(void) {
  uint32_t current_ctrl = DW3000readreg(LED_CTRL_ID, 4);
  current_ctrl |= (1 << LED_CTRL_BLINK_EN_BIT_OFFSET);
  DW3000writereg(LED_CTRL_ID, (uint8_t*)&current_ctrl, 4);
}

/**
 * @brief Set the DW3000 TXLED pin
 *
 */
void DW3000set_TXLED(void) {
  enable_LED_blink();

  uint32_t current_mode;

  current_mode = DW3000readreg(GPIO_MODE_ID, 4);
  current_mode &= ~GPIO_MODE_MSGP3_MODE_BIT_MASK; // Clear the bits
  current_mode |= (0x01 << GPIO_MODE_MSGP3_MODE_BIT_OFFSET); // Set the TXLED mode bit

  DW3000writereg(GPIO_MODE_ID, (uint8_t*)&current_mode, 4);
}

/**
 * @brief read DW3000 OTP memory
 *
 * @param addr OTP address
 * @return uint32_t OTP data
 */
uint32_t DW3000readOTP(uint8_t addr) {
  uint8_t address = addr;
  uint8_t const_02 = 0x02;
  DW3000writereg(OTP_ADDR_ID, &address, 2);
  DW3000writereg(OTP_CFG_ID, &const_02, 2);

  uint32_t reg = DW3000readreg(OTP_RDATA_ID, 4);

  return reg;
}

/**
 * @brief write a fast command to the DW3000
 *
 * @param cmd
 */
void DW3000_writefastCMD_FZ(uint8_t cmd) {
  uint8_t cmd2send = DW3000pack_fast_command(cmd);

  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_RESET);
  sendBytes(&cmd2send, 1);
  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_SET);
}

// clear the IRQ flags
void DW3000_clear_IRQ(void) {
  // FZ: Clear the interrupt flags
  dwt_write32bitreg(SYS_STATUS_ID, SYS_STATUS_MASK);
  DW3000_IRQ_flag = false;
}

void DW3000_clear_all_events(void) {
  DW3000_writefastCMD_FZ(CMD_CLR_IRQS);
}

void DW3000config_CH(uint16_t RX_PCODE, uint16_t TX_PCODE, uint8_t SFD_TYP, channel CH) {
  uint32_t chan_ctrl = 0;

  chan_ctrl |= ((RX_PCODE << CHAN_CTRL_RX_PCODE_BIT_OFFSET) & CHAN_CTRL_RX_PCODE_BIT_MASK) |
               ((TX_PCODE << CHAN_CTRL_TX_PCODE_BIT_OFFSET) & CHAN_CTRL_TX_PCODE_BIT_MASK) |
               ((SFD_TYP  << CHAN_CTRL_SFD_TYPE_BIT_OFFSET) & CHAN_CTRL_SFD_TYPE_BIT_MASK) |
               ((CH       << CHAN_CTRL_RF_CHAN_BIT_OFFSET) & CHAN_CTRL_RF_CHAN_BIT_MASK);

  // FZ: write the channel control register
  DW3000writereg(CHAN_CTRL_ID, (uint8_t*)&chan_ctrl, 4);
}

void DW3000_irq_for_tx_done(void) {
  uint32_t sys_enable = DW3000readreg(SYS_ENABLE_LO_ID, 4);
  sys_enable |= (1 << SYS_ENABLE_LO_TXFRS_ENABLE_BIT_OFFSET); // Enable TX done interrupt
  DW3000writereg(SYS_ENABLE_LO_ID, (uint8_t*)&sys_enable, SYS_ENABLE_LO_LEN);
}

void DW3000_irq_for_rx_done(void) {
  // uint32_t sys_enable = DW3000readreg(SYS_ENABLE_LO_ID, 4);
  // sys_enable |= ((1 << SYS_ENABLE_LO_RXFR_ENABLE_BIT_OFFSET)  |
  //                (1 << SYS_ENABLE_LO_RXPHD_ENABLE_BIT_OFFSET)); // Enable RX done interrupt
  uint32_t sys_enable = SYS_STATUS_RXFCG_BIT_MASK;
  DW3000writereg(SYS_ENABLE_LO_ID, (uint8_t*)&sys_enable, SYS_ENABLE_LO_LEN);
}

void DW3000_irq_for_txrx_done(void) {
  uint32_t sys_enable = DW3000readreg(SYS_ENABLE_LO_ID, 4);
  sys_enable |= ((1 << SYS_ENABLE_LO_TXFRS_ENABLE_BIT_OFFSET)  |
                 (1 << SYS_ENABLE_LO_RXFR_ENABLE_BIT_OFFSET)); // Enable TX and RX done interrupt
  DW3000writereg(SYS_ENABLE_LO_ID, (uint8_t*)&sys_enable, SYS_ENABLE_LO_LEN);
}

void DW3000_disable_RX_timeout(void) {
  ;
}

void DW3000_set_max_sfd_timeout(void) {
  // FZ: Set the maximum SFD timeout
  uint16_t sfd_timeout = RX_SFD_TOC_MASK;
  DW3000writereg(RX_SFD_TOC_ID, (uint8_t*)&sfd_timeout, 2);
}

void DW3000_debug_reg(uint32_t reg, uint8_t len) {
  uint32_t reg_value = DW3000readreg(reg, len);
  printf("DW3000 Register 0x%08lX: 0x%08lX\r\n", reg, reg_value);
}

/**
 * @brief FZ: from: https://gist.github.com/egnor/455d510e11c22deafdec14b09da5bf54
 * Things which are actually documented but easy to miss
 * - If using a 16MHz PRF (PCODE 3 or 4), set RX_TUNE_EN in DGC_CFG
 * - Always change THR_64 in DGC_CFG to 0x32
 * - Always clear DT0B4 in DTUNE0
 * - Always change COMP_DLY in RX_CAL to 0x2
 * - Always change LDO_RLOAD to 0x14
 * - Always change RF_TX_CTRL_1 to 0x0E
 * - Always change RF_TX_CTRL_2 to 0x1C071134 (ch5) or 0x1C010034 (ch9)
 * - Always change PLL_CFG to 0x1F3C (ch5) or 0x0F3C (ch9)
 * - Always change PLL_CFG_LD in PLL_CAL to 0x8 (documented as 0x81 but that's the whole register)
 */
void DW3000_cfg_FZ(void) {
  // Always change THR_64 in DGC_CFG to 0x32
  uint32_t dgc_cfg = DW3000readreg(DGC_CFG_ID, 2);
  dgc_cfg &= ~(DGC_CFG_RX_TUNE_EN_BIT_MASK | DGC_CFG_THR_64_BIT_MASK);
  dgc_cfg |= (1 << DGC_CFG_RX_TUNE_EN_BIT_OFFSET) |
             (0x32 << DGC_CFG_THR_64_BIT_OFFSET); // Enable RX tuning
  DW3000writereg(DGC_CFG_ID, (uint8_t*)&dgc_cfg, 2);

  // Always clear DT0B4 in DTUNE0
  uint32_t dtune0 = DW3000readreg(DTUNE0_ID, 2);
  dtune0 &= ~DTUNE0_DT0B4_BIT_MASK; // Clear the DT0B4 bit
  DW3000writereg(DTUNE0_ID, (uint8_t*)&dtune0, 2);

  // Always change COMP_DLY in RX_CAL to 0x2
  uint32_t rx_cal = DW3000readreg(RX_CAL_CFG_ID, 4);
  rx_cal &= ~RX_CAL_CFG_COMP_DLY_BIT_MASK; // Clear the COMP_DLY
  rx_cal |= (0x2 << RX_CAL_CFG_COMP_DLY_BIT_OFFSET); // Set COMP_DLY to 0x2
  DW3000writereg(RX_CAL_CFG_ID, (uint8_t*)&rx_cal, 4);

  // Always change LDO_RLOAD to 0x14
  uint8_t ldo_cfg = 0x14; // LDO_RLOAD value
  DW3000writereg(LDO_RLOAD_ID, &ldo_cfg, 1);

  // Always change RF_TX_CTRL_1 to 0x0E
  uint8_t rf_tx_ctrl_1 = 0x0E;
  DW3000writereg(RF_TX_CTRL_1_ID, &rf_tx_ctrl_1, 1);

  // Always change RF_TX_CTRL_2 to 0x1C071134 (ch5) or 0x1C010034 (ch9)
  uint32_t channel_ctrl = DW3000readreg(CHAN_CTRL_ID, 4);
  uint32_t channel_sel  = channel_ctrl & CHAN_CTRL_RF_CHAN_BIT_MASK; // Get the current channel
  uint32_t rf_tx_ctrl_2 = (channel_sel == 0) ? 0x1C071134 : 0x1C010034; // Set RF_TX_CTRL_2 based on channel
  DW3000writereg(TX_CTRL_HI_ID, (uint8_t*)&rf_tx_ctrl_2, 4);

  // Always change PLL_CFG to 0x1F3C (ch5) or 0x0F3C (ch9)
  uint16_t pll_cfg = (channel_sel == 0) ? 0x1F3C : 0x0F3C; // Set PLL_CFG based on channel
  DW3000writereg(PLL_CFG_ID, (uint8_t*)&pll_cfg, 2);

  // Always change PLL_CFG_LD in PLL_CAL to 0x8
  uint32_t pll_cal = DW3000readreg(PLL_CAL_ID, 2);
  pll_cal &= ~PLL_CAL_PLL_PLL_CFG_LD_MASK; // Clear the PLL_CFG_LD bits
  pll_cal |= (0x8 << PLL_CAL_PLL_PLL_CFG_LD_OFFSET); // Set PLL_CFG_LD to 0x8
  DW3000writereg(PLL_CAL_ID, (uint8_t*)&pll_cal, 2);
}

/**
 * @brief from: https://gist.github.com/egnor/455d510e11c22deafdec14b09da5bf54
 * Receiver calibration (aka "PGF calibration") must run successfully at startup
 * (and after wakeup or 20Â°C temperature change) for decent performance.
 * The manual describes how to start calibration with RX_CAL and check results
 * in RX_CAL_RESI and RX_CAL_RESQ but misses some details:
 * - Before running calibration, bits 0 (VDDMS1), 2 (VDDMS3), and 8 (VDDIF2) must be set in LDO_CTRL
 * - Before reading RX_CAL_RESI/RESQ, bit 16 in RX_CAL_CFG (the low bit of COMP_DLY) must be set
 * - (After calibration, the previous value of LDO_CTRL should be restored to save power.)
 * - Without these steps, calibration will fail (missing LDOs) and the failure won't be noticed
 *   (result values not being read properly), but the radio will perform very badly.
 */
void DW3000_pgf_cal(void) {
  // pre calibration steps
  uint32_t ldo_ctrl = DW3000readreg(LDO_CTRL_ID, 4);
  uint32_t ldo_ctrl_restore = ldo_ctrl; // Save the original LDO_CTRL value

  // Set VDDMS1, VDDMS3, and VDDIF2 bits in LDO_CTRL
  ldo_ctrl |= (1 << LDO_CTRL_LDO_VDDMS1_EN_BIT_OFFSET) |
              (1 << LDO_CTRL_LDO_VDDMS3_EN_BIT_OFFSET) |
              (1 << LDO_CTRL_LDO_VDDIF2_EN_BIT_OFFSET);
  DW3000writereg(LDO_CTRL_ID, (uint8_t*)&ldo_ctrl, 4);

  // calibration steps
  uint32_t rx_cal_cfg = DW3000readreg(RX_CAL_CFG_ID, 4);
  rx_cal_cfg &= ~RX_CAL_CFG_CAL_MODE_BIT_MASK; // Set the CAL_MODE to 0
  rx_cal_cfg |= (0x01 << RX_CAL_CFG_CAL_MODE_BIT_OFFSET); // set CAL_MODE to calibration mode
  DW3000writereg(RX_CAL_CFG_ID, (uint8_t*)&rx_cal_cfg, 4);
  // Start the calibration
  rx_cal_cfg = DW3000readreg(RX_CAL_CFG_ID, 4);
  rx_cal_cfg |= (0x01 << RX_CAL_CFG_CAL_EN_BIT_OFFSET);
  DW3000writereg(RX_CAL_CFG_ID, (uint8_t*)&rx_cal_cfg, 4);

  // Wait for calibration to complete
  while (!(DW3000readreg(RX_CAL_STS_ID, 1) & 0x01)) {
    HAL_Delay(1); // Delay to avoid busy-waiting
  }

  // back to normal mode
  rx_cal_cfg = DW3000readreg(RX_CAL_CFG_ID, 4);
  rx_cal_cfg &= ~RX_CAL_CFG_CAL_MODE_BIT_MASK; // Set the CAL_MODE to 0
  DW3000writereg(RX_CAL_CFG_ID, (uint8_t*)&rx_cal_cfg, 4);

  // LDO back to restored value to save power
  DW3000writereg(LDO_CTRL_ID, (uint8_t*)&ldo_ctrl_restore, 4);
}

// FZ: the IRQ will be triggered at the very beginning because
// the SPI ready will cause an interrupt
// so we need to clear the interrupt
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
  UNUSED(GPIO_Pin); // Prevent unused variable warning

  if (GPIO_Pin == UWB_IRQ_Pin) {
    DW3000_IRQ_flag = true;
  }
}

// ----------------------------------- FZ: stole from DecaWave API (Jul 18, 2025) -----------------------------------
// Macros and Enumerations for SPI & CLock blocks
//
#define DW3000_SPI_FAC      (0<<6 | 1<<0)
#define DW3000_SPI_FARW     (0<<6 | 0<<0)
#define DW3000_SPI_EAMRW    (1<<6)

// OTP addresses definitions
#define LDOTUNELO_ADDRESS (0x04)
#define LDOTUNEHI_ADDRESS (0x05)
#define PARTID_ADDRESS  (0x06)
#define LOTID_ADDRESS   (0x07)
#define VBAT_ADDRESS    (0x08)
#define VTEMP_ADDRESS   (0x09)
#define XTRIM_ADDRESS   (0x1E)
#define OTPREV_ADDRESS  (0x1F)
#define BIAS_TUNE_ADDRESS (0xA)
#define DGC_TUNE_ADDRESS (0x20)

typedef struct {
  uint32_t      partID ;            // IC Part ID - read during initialisation
  uint32_t      lotID ;             // IC Lot ID - read during initialisation
  uint8_t       bias_tune;          // bias tune code
  uint8_t       dgc_otp_set;        // Flag to check if DGC values are programmed in OTP
  uint8_t       vBatP;              // IC V bat read during production and stored in OTP (Vmeas @ 3V3)
  uint8_t       tempP;              // IC temp read during production and stored in OTP (Tmeas @ 23C)
  uint8_t       longFrames ;        // Flag in non-standard long frame mode
  uint8_t       otprev ;            // OTP revision number (read during initialisation)
  uint8_t       init_xtrim;         // initial XTAL trim value read from OTP (or defaulted to mid-range if OTP not programmed)
  uint8_t       dblbuffon;          // Double RX buffer mode and DB status flag
  uint16_t      sleep_mode;         // Used for automatic reloading of LDO tune and microcode at wake-up
  uint16_t       ststhreshold;       // Threshold for deciding if received STS is good or bad
  dwt_spi_crc_mode_e   spicrc;      // Use SPI CRC when this flag is true
  uint8_t       stsconfig;          // STS configuration mode
  uint8_t       cia_diagnostic;     // CIA dignostic logging level
  dwt_cb_data_t cbData;             // Callback data structure
  dwt_spierrcb_t cbSPIRDErr;        // Callback for SPI read error events
  dwt_cb_t    cbTxDone;             // Callback for TX confirmation event
  dwt_cb_t    cbRxOk;               // Callback for RX good frame event
  dwt_cb_t    cbRxTo;               // Callback for RX timeout events
  dwt_cb_t    cbRxErr;              // Callback for RX error events
  dwt_cb_t    cbSPIErr;             // Callback for SPI error events
  dwt_cb_t    cbSPIRdy;             // Callback for SPI ready events
} localdata;

static localdata _ptr;
static localdata *pdw3000local = &_ptr;

int writetospi(uint16_t headerLength, uint8_t *headerBuffer, uint16_t bodyLength, uint8_t *bodyBuffer) {
  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_RESET);
  sendBytes(headerBuffer, headerLength);
  sendBytes(bodyBuffer, bodyLength);
  // for(int i = 0; i < headerLength; i++) {
  //   SPI.transfer(headerBuffer[i]); // send header
  // }
  // for(int i = 0; i < bodyLength; i++) {
  //   SPI.transfer(bodyBuffer[i]); // write values
  // }
  // delayMicroseconds(5);
  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_SET);

  return 0;
}

int readfromspi(uint16_t headerLength, uint8_t *headerBuffer, uint16_t readLength, uint8_t *readBuffer)
{
  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_RESET);
  sendBytes(headerBuffer, headerLength);
  readBytes(readBuffer, readLength);
  // for(int i = 0; i < headerLength; i++) {
  //   SPI.transfer(headerBuffer[i]); // send header
  // }
  // for(int i = 0; i < readLength; i++) {
  //   readBuffer[i] = SPI.transfer(JUNK); // read values
  // }
  // delayMicroseconds(5);
  HAL_GPIO_WritePin(UWB_CS_GPIO_Port, UWB_CS_Pin, GPIO_PIN_SET);

  return 0;
}

/*! ------------------------------------------------------------------------------------------------------------------
* @brief  this function is used to read/write to the DW3000 device registers
*
* input parameters:
* @param recordNumber  - ID of register file or buffer being accessed
* @param index         - byte index into register file or buffer being accessed
* @param length        - number of bytes being written
* @param buffer        - pointer to buffer containing the 'length' bytes to be written
* @param rw            - DW3000_SPI_WR_BIT/DW3000_SPI_RD_BIT
*
* no return value
*/
void dwt_xfer3000
(
  uint32_t    regFileID,  //0x0, 0x04-0x7F ; 0x10000, 0x10004, 0x10008-0x1007F; 0x20000 etc
  uint16_t    indx,       //sub-index, calculated from regFileID 0..0x7F,
  uint16_t    length,
  uint8_t     *buffer,
  spi_modes_e mode
)
{
  uint8_t  header[2];           // Buffer to compose header in
  uint16_t cnt = 0;             // Counter for length of a header

  uint16_t reg_file     = 0x1F & ((regFileID + indx) >> 16);
  uint16_t reg_offset   = 0x7F &  (regFileID + indx);

  assert(reg_file     <= 0x1F);
  assert(reg_offset   <= 0x7F);
  assert(length       < 0x3100);
  assert(mode == DW3000_SPI_WR_BIT ||\
         mode == DW3000_SPI_RD_BIT ||\
         mode == DW3000_SPI_AND_OR_8 ||\
         mode == DW3000_SPI_AND_OR_16 ||\
         mode == DW3000_SPI_AND_OR_32);

  // Write message header selecting WRITE operation and addresses as appropriate
  uint16_t  addr;
  addr = (reg_file << 9) | (reg_offset << 2);

  header[0] = (uint8_t)((mode | addr) >> 8);   //  & 0xFF; //bit7 + addr[4:0] + sub_addr[6:6]
  header[1] = (uint8_t)(addr | (mode & 0x03)); // & 0xFF; //EAM: subaddr[5:0]+ R/W/AND_OR

  if (/*reg_offset == 0 && */length == 0) {   /* Fast Access Commands (FAC)
        * only write operation is possible for this mode
        * bit_7=one is W operation, bit_6=zero: FastAccess command, bit_[5..1] addr, bits_0=one: MODE of FastAccess
        */
      assert(mode == DW3000_SPI_WR_BIT);

      header[0] = (uint8_t)((DW3000_SPI_WR_BIT>>8) | (regFileID<<1) | DW3000_SPI_FAC);
      cnt = 1;
  }
  else if (reg_offset == 0 /*&& length > 0*/ && (mode == DW3000_SPI_WR_BIT || mode == DW3000_SPI_RD_BIT))
  {   /* Fast Access Commands with Read/Write support (FACRW)
        * bit_7 is R/W operation, bit_6=zero: FastAccess command, bit_[5..1] addr, bits_0=zero: MODE of FastAccess
        */
      header[0] |= DW3000_SPI_FARW;
      cnt = 1;
  }
  else
  {  /* Extended Address Mode with Read/Write support (EAMRW)
      * b[0] = bit_7 is R/W operation, bit_6 one = ExtendedAddressMode;
      * b[1] = addr<<2 | (mode&0x3)
      */
    header[0] |= DW3000_SPI_EAMRW;
    cnt = 2;
  }

  switch (mode)
  {
    case    DW3000_SPI_AND_OR_8:
    case    DW3000_SPI_AND_OR_16:
    case    DW3000_SPI_AND_OR_32:
    case    DW3000_SPI_WR_BIT:
    {
      {
        writetospi(cnt, header, length, buffer);
      }
      break;
    }

    case DW3000_SPI_RD_BIT:
    {
      readfromspi(cnt, header, length, buffer);
      break;
    }

    default:
      while(1);
      break;
  }
} // end dwt_xfer3000()

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to write to the DW3000 device registers
 *
 * input parameters:
 * @param recordNumber  - ID of register file or buffer being accessed
 * @param index         - byte index into register file or buffer being accessed
 * @param length        - number of bytes being written
 * @param buffer        - pointer to buffer containing the 'length' bytes to be written
 *
 * output parameters
 *
 * no return value
 */
//static
void dwt_writetodevice(uint32_t regFileID, uint16_t index, uint16_t length, uint8_t *buffer) {
  dwt_xfer3000(regFileID, index, length, buffer, DW3000_SPI_WR_BIT);
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to read from the DW3000 device registers
 *
 * @param recordNumber  - ID of register file or buffer being accessed
 * @param index         - byte index into register file or buffer being accessed
 * @param length        - number of bytes being read
 * @param buffer        - pointer to buffer in which to return the read data.
 *
 * output parameters
 *
 * no return value
 */
//static
void dwt_readfromdevice
(
  uint32_t  regFileID,
  uint16_t  index,
  uint16_t  length,
  uint8_t   *buffer
)
{
  dwt_xfer3000(regFileID, index, length, buffer, DW3000_SPI_RD_BIT);
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to read 32-bit value from the DW3000 device registers
 *
 * input parameters:
 * @param regFileID - ID of register file or buffer being accessed
 * @param regOffset - the index into register file or buffer being accessed
 *
 * output parameters
 *
 * returns 32 bit register value
 */
uint32_t dwt_read32bitoffsetreg(uint32_t regFileID, uint16_t regOffset) {
  int     j ;
  uint32_t  regval = 0 ;
  uint8_t   buffer[4] ;

  dwt_readfromdevice(regFileID,regOffset,4,buffer); // Read 4 bytes (32-bits) register into buffer

  for (j = 3 ; j >= 0 ; j --) {
    regval = (regval << 8) + buffer[j] ;
  }

  return (regval);

} // end dwt_read32bitoffsetreg()

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to read 16-bit value from the DW3000 device registers
 *
 * input parameters:
 * @param regFileID - ID of register file or buffer being accessed
 * @param regOffset - the index into register file or buffer being accessed
 *
 * output parameters
 *
 * returns 16 bit register value
 */
uint16_t dwt_read16bitoffsetreg(uint32_t regFileID, uint16_t regOffset)
{
    uint16_t  regval = 0 ;
    uint8_t   buffer[2] ;

    dwt_readfromdevice(regFileID,regOffset,2,buffer); // Read 2 bytes (16-bits) register into buffer

    regval = ((uint16_t)buffer[1] << 8) + buffer[0] ;
    return regval ;

} // end dwt_read16bitoffsetreg()

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to read an 8-bit value from the DW3000 device registers
 *
 * input parameters:
 * @param regFileID - ID of register file or buffer being accessed
 * @param regOffset - the index into register file or buffer being accessed
 *
 * output parameters
 *
 * returns 8-bit register value
 */
uint8_t dwt_read8bitoffsetreg(uint32_t regFileID, uint16_t regOffset)
{
  uint8_t regval;
  uint8_t buffer[1];

  dwt_readfromdevice(regFileID, regOffset, 1, buffer);
  regval = buffer[0] ;

  return regval ;
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to write 32-bit value to the DW3000 device registers
 *
 * input parameters:
 * @param regFileID - ID of register file or buffer being accessed
 * @param regOffset - the index into register file or buffer being accessed
 * @param regval    - the value to write
 *
 * output parameters
 *
 * no return value
 */
void dwt_write32bitoffsetreg(uint32_t regFileID, uint16_t regOffset, uint32_t regval)
{
    int     j ;
    uint8_t   buffer[4] ;

    for ( j = 0 ; j < 4 ; j++ )
    {
        buffer[j] = (uint8_t)regval;
        regval >>= 8 ;
    }

    dwt_writetodevice(regFileID,regOffset,4,buffer);
} // end dwt_write32bitoffsetreg()

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to write 16-bit value to the DW3000 device registers
 *
 * input parameters:
 * @param regFileID - ID of register file or buffer being accessed
 * @param regOffset - the index into register file or buffer being accessed
 * @param regval    - the value to write
 *
 * output parameters
 *
 * no return value
 */
void dwt_write16bitoffsetreg(uint32_t regFileID, uint16_t regOffset, uint16_t regval)
{
    uint8_t   buffer[2] ;

    buffer[0] = (uint8_t)regval;
    buffer[1] = regval >> 8 ;

    dwt_writetodevice(regFileID,regOffset,2,buffer);
} // end dwt_write16bitoffsetreg()

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to write an 8-bit value to the DW3000 device registers
 *
 * input parameters:
 * @param regFileID - ID of register file or buffer being accessed
 * @param regOffset - the index into register file or buffer being accessed
 * @param regval    - the value to write
 *
 * output parameters
 *
 * no return value
 */
void dwt_write8bitoffsetreg(uint32_t regFileID, uint16_t regOffset, uint8_t regval)
{
    uint8_t   buffer[1];
    buffer[0] = regval;
    dwt_writetodevice(regFileID, regOffset, 1, buffer);
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to modify a 32-bit value to the DW3000 device registers
 *
 * input parameters:
 * @param regFileID :   ID of register file or buffer being accessed
 * @param regOffset :   the index into register file or buffer being accessed
 * @param regval_and:   the value to AND to register
 * @param regval_or :   the value to OR to register
 * @output          :   no return value
 */
void dwt_modify32bitoffsetreg(const uint32_t regFileID, const uint16_t regOffset, const uint32_t _and, const uint32_t _or)
{
    uint8_t buf[8];
    buf[0] = (uint8_t)_and;//       &0xFF;
    buf[1] = (uint8_t)(_and>>8);//  &0xFF;
    buf[2] = (uint8_t)(_and>>16);// &0xFF;
    buf[3] = (uint8_t)(_and>>24);// &0xFF;
    buf[4] = (uint8_t)_or;//        &0xFF;
    buf[5] = (uint8_t)(_or>>8);//   &0xFF;
    buf[6] = (uint8_t)(_or>>16);//  &0xFF;
    buf[7] = (uint8_t)(_or>>24);//  &0xFF;
    dwt_xfer3000(regFileID, regOffset, sizeof(buf), buf, DW3000_SPI_AND_OR_32);
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to modify a 16-bit value to the DW3000 device registers
 *
 * input parameters:
 * @param regFileID :   ID of register file or buffer being accessed
 * @param regOffset :   the index into register file or buffer being accessed
 * @param regval_and:   the value to AND to register
 * @param regval_or :   the value to OR to register
 * @output          :   no return value
 */
void dwt_modify16bitoffsetreg(const uint32_t regFileID, const uint16_t regOffset, const uint16_t _and, const uint16_t _or)
{
    uint8_t buf[4];
    buf[0] = (uint8_t)_and;//       &0xFF;
    buf[1] = (uint8_t)(_and>>8);//  &0xFF;
    buf[2] = (uint8_t)_or;//        &0xFF;
    buf[3] = (uint8_t)(_or>>8);//   &0xFF;
    dwt_xfer3000(regFileID, regOffset, sizeof(buf), buf, DW3000_SPI_AND_OR_16);
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief  this function is used to modify a 8-bit value to the DW3000 device registers
 *
 * input parameters:
 * @param regFileID :   ID of register file or buffer being accessed
 * @param regOffset :   the index into register file or buffer being accessed
 * @param regval_and:   the value to AND to register
 * @param regval_or :   the value to OR to register
 * @output          :   no return value
 */
void dwt_modify8bitoffsetreg(const uint32_t regFileID, const uint16_t regOffset, const uint8_t _and, const uint8_t _or) {
  uint8_t buf[2];
  buf[0] = _and;
  buf[1] = _or;
  dwt_xfer3000(regFileID, regOffset, sizeof(buf),buf, DW3000_SPI_AND_OR_8);
}

void DW3000_clearaonconfig(void) {
  // Clear any AON auto download bits (as reset will trigger AON download)
  dwt_write16bitoffsetreg(AON_DIG_CFG_ID, 0, 0x00);
  // Clear the wake-up configuration
  dwt_write8bitoffsetreg(ANA_CFG_ID, 0, 0x00);
  // Upload the new configuration
  // Copy config to AON - upload the new configuration
  dwt_write8bitoffsetreg(AON_CTRL_ID, 0, 0);
  dwt_write8bitoffsetreg(AON_CTRL_ID, 0, AON_CTRL_ARRAY_SAVE_BIT_MASK);
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief function to read the OTP memory.
 *
 * input parameters
 * @param address - address to read at
 *
 * output parameters
 *
 * returns the 32bit of read data
 */
uint32_t _dwt_otpread(uint16_t address)
{
  uint32_t ret_data;

  // Set manual access mode
  dwt_write16bitoffsetreg(OTP_CFG_ID, 0, 0x0001);
  // set the address
  dwt_write16bitoffsetreg(OTP_ADDR_ID, 0, address);
  // Assert the read strobe
  dwt_write16bitoffsetreg(OTP_CFG_ID, 0, 0x0002);
  // attempt a read from OTP address
  ret_data = dwt_read32bitoffsetreg(OTP_RDATA_ID, 0);

  // Return the 32bit of read data
  return ret_data;
}

void _dwt_prog_ldo_and_bias_tune(void)
{
  dwt_or16bitoffsetreg(OTP_CFG_ID, 0, LDO_BIAS_KICK);
  dwt_and_or16bitoffsetreg(BIAS_CTRL_ID, 0, (uint16_t)~BIAS_CTRL_BIAS_BIT_MASK, pdw3000local->bias_tune);
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief this function resets the DW3000
 *
 * NOTE: SPI rate must be <= 7MHz before a call to this function as the device will use FOSC/4 as part of internal reset
 *
 * input parameters:
 *
 * output parameters
 *
 * no return value
 */
void dwt_softreset(void) {
  //clear any AON configurations (this will leave the device at FOSC/4, thus we need low SPI rate)
  dwt_clearaonconfig();

  //make sure the new AON array config has been set
  HAL_Delay(1);

  //need to make sure clock is not PLL as the PLL will be switched off as part of reset
  dwt_or8bitoffsetreg(CLK_CTRL_ID, 0, FORCE_SYSCLK_FOSC);

  // Reset HIF, TX, RX and PMSC
  dwt_write8bitoffsetreg(SOFT_RST_ID, 0, DWT_RESET_ALL);

  // DW3000 needs a 10us sleep to let clk PLL lock after reset - the PLL will automatically lock after the reset
  // Could also have polled the PLL lock flag, but then the SPI needs to be <= 7MHz !! So a simple delay is easier
  HAL_Delay(1);

  //reset buffer to process RX_BUFFER_0 next - if in double buffer mode (clear bit 1 if set)
  pdw3000local->dblbuffon = DBL_BUFF_ACCESS_BUFFER_0;
  pdw3000local->sleep_mode = 0;
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief this function resets the DW3000
 *
 * NOTE: SPI rate must be <= 7MHz before a call to this function as the device will use FOSC/4 as part of internal reset
 *
 */
void DW3000softReset(void) {
  //clear any AON configurations (this will leave the device at FOSC/4, thus we need low SPI rate)
  DW3000_clearaonconfig();

  //make sure the new AON array config has been set
  HAL_Delay(1);

  //need to make sure clock is not PLL as the PLL will be switched off as part of reset
  dwt_or8bitoffsetreg(CLK_CTRL_ID, 0, FORCE_SYSCLK_FOSC);

  // Reset HIF, TX, RX and PMSC
  dwt_write8bitoffsetreg(SOFT_RST_ID, 0, DWT_RESET_ALL);

  // DW3000 needs a 10us sleep to let clk PLL lock after reset - the PLL will automatically lock after the reset
  // Could also have polled the PLL lock flag, but then the SPI needs to be <= 7MHz !! So a simple delay is easier
  HAL_Delay(1);

  //reset buffer to process RX_BUFFER_0 next - if in double buffer mode (clear bit 1 if set)
  pdw3000local->dblbuffon = DBL_BUFF_ACCESS_BUFFER_0;
  pdw3000local->sleep_mode = 0;
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief This is used to return the read device type and revision information of the DW3000 device (MP part is 0xDECA0300)
 *
 * input parameters
 *
 * output parameters
 *
 * returns the read value which for DW3000 is 0xDECA0312/0xDECA0302
 */
uint32_t dwt_readdevid(void)
{
  return dwt_read32bitoffsetreg(DEV_ID_ID, 0);
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief this reads the device ID and checks if it is the right one
 *
 * input parameters
 * None
 *
 * output parameters
 *
 * returns DWT_SUCCESS for success, or DWT_ERROR for error
 */
int dwt_check_dev_id(void)
{
  uint32_t  dev_id;

  dev_id = dwt_readdevid();

  printf("DEVICE ID: %lX\r\n", dev_id);

  if (!((DWT_DW3000_PDOA_DEV_ID == dev_id) || (DWT_DW3000_DEV_ID == dev_id))) {
    return DWT_ERROR;
  }

  return DWT_SUCCESS;
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief This function initialises the DW3000 transceiver:
 * it reads its DEV_ID register (address 0x00) to verify the IC is one supported
 * by this software (e.g. DW3000 32-bit device ID value is 0xDECA03xx).  Then it
 * does any initial once only device configurations needed for use and initialises
 * as necessary any static data items belonging to this low-level driver.
 *
 * NOTES:
 * 1.it also reads and applies LDO and BIAS tune and crystal trim values from OTP memory
 * 2.it is assumed this function is called after a reset or on power up of the DW3000
 *
 * input parameters
 * @param mode - mask which defines which OTP values to read.
 *
 * output parameters
 *
 * returns DWT_SUCCESS for success, or DWT_ERROR for error
 */
int dwt_initialise(uint8_t mode)
{
//  uint16_t otp_addr;
//  uint32_t devid;
  uint32_t ldo_tune_lo;
  uint32_t ldo_tune_hi;

  pdw3000local->dblbuffon = DBL_BUFF_OFF; // Double buffer mode off by default / clear the flag
  pdw3000local->sleep_mode = DWT_RUNSAR;  // Configure RUN_SAR on wake by default as it is needed when running PGF_CAL
  pdw3000local->spicrc = DWT_SPI_CRC_MODE_NO;
  pdw3000local->stsconfig = 0; //STS off
  pdw3000local->vBatP = 0;
  pdw3000local->tempP = 0;

  pdw3000local->cbTxDone = NULL;
  pdw3000local->cbRxOk = NULL;
  pdw3000local->cbRxTo = NULL;
  pdw3000local->cbRxErr = NULL;
  pdw3000local->cbSPIRdy = NULL;
  pdw3000local->cbSPIErr = NULL;

  // Read and validate device ID return -1 if not recognised
  if (dwt_check_dev_id() != DWT_SUCCESS) {
    return DWT_ERROR;
  }

  // check if the DW3000 is present
  // uint32_t dev_id = DW3000readreg(DEV_ID_ID, 4);
  // printf("DW3000 Device ID: 0x%08lX\r\n", dev_id);

  // if (dev_id == (uint32_t)DWT_DW3000_DEV_ID) {
  //   blink_led(PIN_LED1_GPIO_Port, PIN_LED1_Pin, 50);
  // } else {
  //   return DWT_ERROR;
  // }

  //Read LDO_TUNE and BIAS_TUNE from OTP
  ldo_tune_lo = _dwt_otpread(LDOTUNELO_ADDRESS);
  ldo_tune_hi = _dwt_otpread(LDOTUNEHI_ADDRESS);
  pdw3000local->bias_tune = (_dwt_otpread(BIAS_TUNE_ADDRESS) >> 16) & BIAS_CTRL_BIAS_BIT_MASK;

  if ((ldo_tune_lo != 0) && (ldo_tune_hi != 0) && (pdw3000local->bias_tune != 0)) {
    _dwt_prog_ldo_and_bias_tune();
  }

  // Read DGC_CFG from OTP
  if (_dwt_otpread(DGC_TUNE_ADDRESS) == DWT_DGC_CFG0) {
    pdw3000local->dgc_otp_set = DWT_DGC_LOAD_FROM_OTP;
  } else {
    pdw3000local->dgc_otp_set = DWT_DGC_LOAD_FROM_SW;
  }

  // Load Part and Lot ID from OTP
  if(!(mode & DWT_READ_OTP_PID)) {
    pdw3000local->partID = _dwt_otpread(PARTID_ADDRESS);
  }
  if (!(mode & DWT_READ_OTP_LID)) {
    pdw3000local->lotID = _dwt_otpread(LOTID_ADDRESS);
  }
  if (!(mode & DWT_READ_OTP_BAT)) {
    pdw3000local->vBatP = (uint8_t)_dwt_otpread(VBAT_ADDRESS);
  }
  if (!(mode & DWT_READ_OTP_TMP)) {
    pdw3000local->tempP = (uint8_t)_dwt_otpread(VTEMP_ADDRESS);
  }

  if(pdw3000local->tempP == 0) {  //if the reference temperature has not been programmed in OTP (early eng samples) set to default value
      pdw3000local->tempP = 0x85 ; //@temp of 20 deg
  }

  if(pdw3000local->vBatP == 0) {//if the reference voltage has not been programmed in OTP (early eng samples) set to default value
    pdw3000local->vBatP = 0x74 ;  //@Vref of 3.0V
  }

  pdw3000local->otprev = (uint8_t) _dwt_otpread(OTPREV_ADDRESS);

  pdw3000local->init_xtrim = _dwt_otpread(XTRIM_ADDRESS) & 0x7f;

  if(pdw3000local->init_xtrim == 0) {
    pdw3000local->init_xtrim = 0x2E ; //set default value
    // printf("XTRIM OTP READ FAIL\r\n");
  }

  dwt_write8bitoffsetreg(XTAL_ID, 0, pdw3000local->init_xtrim);

  return DWT_SUCCESS ;

} // end dwt_initialise()

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief This is used to set up Tx/Rx GPIOs which could be used to control LEDs
 * Note: not completely IC dependent, also needs board with LEDS fitted on right I/O lines
 *       this function enables GPIOs 2 and 3 which are connected to LED3 and LED4 on EVB1000
 *
 * input parameters
 * @param mode - this is a bit field interpreted as follows:
 *          - bit 0: 1 to enable LEDs, 0 to disable them
 *          - bit 1: 1 to make LEDs blink once on init. Only valid if bit 0 is set (enable LEDs)
 *          - bit 2 to 7: reserved
 *
 * output parameters none
 *
 * no return value
 */
void dwt_setleds(uint8_t mode) {
  uint32_t reg;
  if (mode & DWT_LEDS_ENABLE) {
    // Set up MFIO for LED output.
    dwt_modify32bitoffsetreg(GPIO_MODE_ID, 0, ~(GPIO_MODE_MSGP3_MODE_BIT_MASK | GPIO_MODE_MSGP2_MODE_BIT_MASK), (GPIO_PIN2_RXLED | GPIO_PIN3_TXLED));

    // Enable LP Oscillator to run from counter and turn on de-bounce clock.
    dwt_or32bitoffsetreg(CLK_CTRL_ID, 0, (CLK_CTRL_GPIO_DCLK_EN_BIT_MASK | CLK_CTRL_LP_CLK_EN_BIT_MASK));

    // Enable LEDs to blink and set default blink time.
    reg = LED_CTRL_BLINK_EN_BIT_MASK | DWT_LEDS_BLINK_TIME_DEF;
    // Make LEDs blink once if requested.
    if (mode & DWT_LEDS_INIT_BLINK) {
        reg |= LED_CTRL_FORCE_TRIGGER_BIT_MASK;
    }
    dwt_write32bitreg(LED_CTRL_ID, reg);
    // Clear force blink bits if needed.
    if(mode & DWT_LEDS_INIT_BLINK) {
      reg &= (~LED_CTRL_FORCE_TRIGGER_BIT_MASK);
      dwt_write32bitreg(LED_CTRL_ID, reg);
    }
  } else {
    // Clear the GPIO bits that are used for LED control.
    dwt_and32bitoffsetreg(GPIO_MODE_ID, 0, ~(GPIO_MODE_MSGP2_MODE_BIT_MASK | GPIO_MODE_MSGP3_MODE_BIT_MASK));
    dwt_and16bitoffsetreg(LED_CTRL_ID, 0, (uint16_t) ~LED_CTRL_BLINK_EN_BIT_MASK);
  }
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief This is used to read the data from the RX buffer, from an offset location give by offset parameter
 *
 * input parameters
 * @param buffer - the buffer into which the data will be read
 * @param length - the length of data to read (in bytes)
 * @param rxBufferOffset - the offset in the rx buffer from which to read the data
 *
 * output parameters
 *
 * no return value
 */
void dwt_readrxdata(uint8_t *buffer, uint16_t length, uint16_t rxBufferOffset)
{
  uint32_t  rx_buff_addr;

  if (pdw3000local->dblbuffon == DBL_BUFF_ACCESS_BUFFER_1)  //if the flag is 0x3 we are reading from RX_BUFFER_1
  {
    rx_buff_addr=RX_BUFFER_1_ID;
  }
  else //reading from RX_BUFFER_0 - also when non-double buffer mode
  {
    rx_buff_addr=RX_BUFFER_0_ID;
  }

  if ((rxBufferOffset + length) <= RX_BUFFER_MAX_LEN)
  {
    if(rxBufferOffset <= REG_DIRECT_OFFSET_MAX_LEN)
    {
      /* Directly read data from the IC to the buffer */
      dwt_readfromdevice(rx_buff_addr,rxBufferOffset,length,buffer);
    }
    else
    {
      /* Program the indirect offset registers B for specified offset to RX buffer */
      dwt_write32bitreg(INDIRECT_ADDR_A_ID, (rx_buff_addr >> 16) );
      dwt_write32bitreg(ADDR_OFFSET_A_ID,   rxBufferOffset);

      /* Indirectly read data from the IC to the buffer */
      dwt_readfromdevice(INDIRECT_POINTER_A_ID, 0, length, buffer);
    }
  }
}

static uint16_t get_sts_mnth (uint16_t cipher, uint8_t threshold, uint8_t shift_val)
{
    uint32_t  value;
    uint16_t  mod_val;

    value = cipher* (uint32_t)threshold;
    if (shift_val == 3)
    {
        value *= SQRT_FACTOR;//Factor to sqrt(2)
        value >>= SQRT_SHIFT_VAL;
    }

    mod_val = value % MOD_VALUE+ HALF_MOD;
    value >>= SHIFT_VALUE;
    /* Check if modulo greater than MOD_VALUE, if yes add 1 */
    if (mod_val >= MOD_VALUE)
  {
        value += 1;
  }

    return (uint16_t)value;
}

// -------------------------------------------------------------------------------------------------------------------
// Module Macro definitions and enumerations
//

//#define DWT_API_ERROR_CHECK  /* API checks config input parameters */

/* STS Minimum Threshold (STS_MNTH) needs to be adjusted with changing STS length.
To adjust the STS_MNTH following formula can be used: STS_MNTH = SQRT(X/Y)*default_STS_MNTH
default_STS_MNTH is 0x10
X is the length of the STS in units of 8 (i.e. 8 for 64 length, 16 for 128 length etc.)
Y is either 8 or 16, 8 when no PDOA or PDOA mode 1 and 16 for PDOA mode 3

The API does not use the formula and the STS_MNTH value is derived from approximation formula as given by get_sts_mnth()
function. The API here supports STS lengths as listed in: dwt_sts_lengths_e enum, which are: 32, 64, 128, 256, 512, 1024, 2048
The enum value is used as the index into sts_length_factors array. The array has values which are generated by:
val = SQRT(stsLength/16)*2048
*/
const uint16_t sts_length_factors[STS_LEN_SUPPORTED]=
{
    1024,1448,2048,2896,4096,5793,8192
};

/*! ------------------------------------------------------------------------------------------------------------------
* @brief This API function is used to configure frame preamble length, the frame premable length can be
* configured in steps of 8, from 16 to 2048 symbols. If a non-zero value is configured, then the TXPSR_PE setting is ignored.
*
* input parameters:
* @param preambleLength - sets the length of the preamble, value of 0 disables this setting and the length of the
*                         frame will be dependent on the TXPSR_PE setting as configured by dwt_configure function
*
* output parameters
*
* no return value
*/
void dwt_setplenfine(uint8_t preambleLength)
{
    dwt_write8bitoffsetreg(TX_FCTRL_HI_ID, 1, preambleLength);
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief This function can place DW3000 into IDLE/IDLE_PLL or IDLE_RC mode when it is not actively in TX or RX.
 *
 * input parameters
 * @param state - DWT_DW_IDLE (1) to put DW3000 into IDLE/IDLE_PLL state; DWT_DW_INIT (0) to put DW3000 into INIT_RC state;
 *                DWT_DW_IDLE_RC (2) to put DW3000 into IDLE_RC state.
 *
 * output parameters none
 *
 * no return value
 */
void dwt_setdwstate(uint8_t state)
{
    if (state == DWT_DW_IDLE) // Set the auto INIT2IDLE bit so that DW3000 enters IDLE mode before switching clocks to system_PLL
    //NOTE: PLL should be configured prior to this, and the device should be in IDLE_RC (if the PLL does not lock device will remain in IDLE_RC)
    {
        //switch clock to auto - if coming here from INIT_RC the clock will be FOSC/4, need to switch to auto prior to setting auto INIT2IDLE bit
        dwt_force_clocks(FORCE_CLK_AUTO);
        dwt_or8bitoffsetreg(SEQ_CTRL_ID, 0x01, SEQ_CTRL_AINIT2IDLE_BIT_MASK>>8);
    }
    else if(state == DWT_DW_IDLE_RC)  //Change state to IDLE_RC and clear auto INIT2IDLE bit
    {
        //switch clock to FOSC
        dwt_or8bitoffsetreg(CLK_CTRL_ID, 0, FORCE_SYSCLK_FOSC);
        //clear the auto INIT2IDLE bit and set FORCE2INIT
        dwt_modify32bitoffsetreg(SEQ_CTRL_ID, 0x0, (uint32_t) ~SEQ_CTRL_AINIT2IDLE_BIT_MASK, SEQ_CTRL_FORCE2INIT_BIT_MASK);
        //clear force bits (device will stay in IDLE_RC)
        dwt_and8bitoffsetreg(SEQ_CTRL_ID, 0x2, (uint8_t) ~(SEQ_CTRL_FORCE2INIT_BIT_MASK>>16));
        //switch clock to auto
        dwt_force_clocks(FORCE_CLK_AUTO);
    }
    else
    //NOTE: the SPI rate needs to be <= 7MHz as device is switching to INIT_RC state
    {
        dwt_or8bitoffsetreg(CLK_CTRL_ID, 0, FORCE_SYSCLK_FOSCDIV4);
        //clear the auto INIT2IDLE bit and set FORCE2INIT
        dwt_modify32bitoffsetreg(SEQ_CTRL_ID, 0x0, (uint32_t) ~SEQ_CTRL_AINIT2IDLE_BIT_MASK, SEQ_CTRL_FORCE2INIT_BIT_MASK);
        dwt_and8bitoffsetreg(SEQ_CTRL_ID, 0x2, (uint8_t) ~(SEQ_CTRL_FORCE2INIT_BIT_MASK>>16));
  }
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief function to enable/disable clocks to particular digital blocks/system
 *
 * input parameters
 * @param clocks - set of clocks to enable/disable
 *
 * output parameters none
 *
 * no return value
 */
void dwt_force_clocks(int clocks)
{

    if (clocks == FORCE_CLK_SYS_TX)
    {
        uint16_t regvalue0 = CLK_CTRL_TX_BUF_CLK_ON_BIT_MASK | CLK_CTRL_RX_BUF_CLK_ON_BIT_MASK;

        //SYS_CLK_SEL = PLL
        regvalue0 |= ((uint16_t) FORCE_SYSCLK_PLL) << CLK_CTRL_SYS_CLK_SEL_BIT_OFFSET;

        //TX_CLK_SEL = ON
        regvalue0 |= ((uint16_t) FORCE_CLK_PLL) << CLK_CTRL_TX_CLK_SEL_BIT_OFFSET;

        dwt_write16bitoffsetreg(CLK_CTRL_ID, 0x0, regvalue0);

    }

    if (clocks == FORCE_CLK_AUTO)
    {
        //Restore auto clock mode
        dwt_write16bitoffsetreg(CLK_CTRL_ID, 0x0, (uint16_t) DWT_AUTO_CLKS);  //we only need to restore the low 16 bits as they are the only ones to change as a result of  FORCE_CLK_SYS_TX
    }

} // end dwt_force_clocks()

/*! ------------------------------------------------------------------------------------------------------------------
* @brief This function is a static function used to 'kick' the DGC upon wakeup from sleep. It will load the
*        required DGC configuration from OTP based upon what channel was set to be used in dwt_configure().
*
* input parameters
* @param channel - specifies the operating channel (e.g. 5 or 9)
*
* output parameters
*
* no return value
*/
static
void _dwt_kick_dgc_on_wakeup(int8_t channel)
{
    /* The DGC_SEL bit must be set to '0' for channel 5 and '1' for channel 9 */
    if (channel == 5)
    {
        dwt_modify32bitoffsetreg(OTP_CFG_ID, 0, ~(OTP_CFG_DGC_SEL_BIT_MASK),
                (DWT_DGC_SEL_CH5 << OTP_CFG_DGC_SEL_BIT_OFFSET) | OTP_CFG_DGC_KICK_BIT_MASK);
    }
    else if (channel == 9)
    {
        dwt_modify32bitoffsetreg(OTP_CFG_ID, 0, ~(OTP_CFG_DGC_SEL_BIT_MASK),
                (DWT_DGC_SEL_CH9 << OTP_CFG_DGC_SEL_BIT_OFFSET) | OTP_CFG_DGC_KICK_BIT_MASK);
    }
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief This function sets the default values of the lookup tables depending on the channel selected.
 *
 * input parameters
 * @param[in] channel - Channel that the device will be transmitting/receiving on.
 *
 * no return value
 */
void dwt_configmrxlut(uint8_t channel)
{
  uint32_t lut0, lut1, lut2, lut3, lut4, lut5, lut6 = 0;

    if (channel == 5)
    {
        lut0 = (uint32_t)CH5_DGC_LUT_0;
        lut1 = (uint32_t)CH5_DGC_LUT_1;
        lut2 = (uint32_t)CH5_DGC_LUT_2;
        lut3 = (uint32_t)CH5_DGC_LUT_3;
        lut4 = (uint32_t)CH5_DGC_LUT_4;
        lut5 = (uint32_t)CH5_DGC_LUT_5;
        lut6 = (uint32_t)CH5_DGC_LUT_6;
    }
    else
    {
        lut0 = (uint32_t)CH9_DGC_LUT_0;
        lut1 = (uint32_t)CH9_DGC_LUT_1;
        lut2 = (uint32_t)CH9_DGC_LUT_2;
        lut3 = (uint32_t)CH9_DGC_LUT_3;
        lut4 = (uint32_t)CH9_DGC_LUT_4;
        lut5 = (uint32_t)CH9_DGC_LUT_5;
        lut6 = (uint32_t)CH9_DGC_LUT_6;
    }
    dwt_write32bitoffsetreg(DGC_LUT_0_CFG_ID, 0x0, lut0);
    dwt_write32bitoffsetreg(DGC_LUT_1_CFG_ID, 0x0, lut1);
    dwt_write32bitoffsetreg(DGC_LUT_2_CFG_ID, 0x0, lut2);
    dwt_write32bitoffsetreg(DGC_LUT_3_CFG_ID, 0x0, lut3);
    dwt_write32bitoffsetreg(DGC_LUT_4_CFG_ID, 0x0, lut4);
    dwt_write32bitoffsetreg(DGC_LUT_5_CFG_ID, 0x0, lut5);
    dwt_write32bitoffsetreg(DGC_LUT_6_CFG_ID, 0x0, lut6);
    dwt_write32bitoffsetreg(DGC_CFG0_ID, 0x0, DWT_DGC_CFG0);
    dwt_write32bitoffsetreg(DGC_CFG1_ID, 0x0, DWT_DGC_CFG1);
}

/*! ------------------------------------------------------------------------------------------------------------------
 *
 * @brief This function runs the PGF calibration. This is needed prior to reception.
 * Note: If the RX calibration routine fails the device receiver performance will be severely affected, the application should reset and try again
 *
 * input parameters
 * @param ldoen    -   if set to 1 the function will enable LDOs prior to calibration and disable afterwards.
 *
 * return result of PGF calibration (DWT_ERROR/-1 = error)
 *
 */
int dwt_pgf_cal(uint8_t ldoen)
{
    uint8_t temp;
    uint16_t val;

    //PGF needs LDOs turned on - ensure PGF LDOs are enabled
    if (ldoen == 1)
    {
        val = dwt_read16bitoffsetreg(LDO_CTRL_ID, 0);

        dwt_or16bitoffsetreg(LDO_CTRL_ID, 0, (
            LDO_CTRL_LDO_VDDIF2_EN_BIT_MASK |
            LDO_CTRL_LDO_VDDMS3_EN_BIT_MASK |
            LDO_CTRL_LDO_VDDMS1_EN_BIT_MASK));
    }

    //Run PGF Cal
    temp = dwt_run_pgfcal();

    //Turn off RX LDOs if previously off
    if (ldoen == 1)
    {
        dwt_and16bitoffsetreg(LDO_CTRL_ID, 0, val); // restore LDO values
    }
    return temp;
}

/*! ------------------------------------------------------------------------------------------------------------------
 *
 * @brief This function runs the PGF calibration. This is needed prior to reception.
 *
 * input parameters
 *
 * return result of PGF calibration (DWT_ERROR/-1 = error)
 *
 */
int dwt_run_pgfcal(void)
{
    int result = DWT_SUCCESS;
    uint32_t    data;
    uint32_t    val = 0;
    uint8_t     cnt,flag;
    //put into cal mode
    //Turn on delay mode
    data = (((uint32_t)0x02) << RX_CAL_CFG_COMP_DLY_BIT_OFFSET) | (RX_CAL_CFG_CAL_MODE_BIT_MASK & 0x1);
    dwt_write32bitoffsetreg(RX_CAL_CFG_ID, 0x0, data);
    // Trigger PGF Cal
    dwt_or8bitoffsetreg(RX_CAL_CFG_ID, 0x0, RX_CAL_CFG_CAL_EN_BIT_MASK);

    for (flag=1,cnt=0;cnt<MAX_RETRIES_FOR_PGF;cnt++)
    {
        HAL_Delay(1);
        if(dwt_read8bitoffsetreg(RX_CAL_STS_ID, 0x0) == 1)
        {//PGF cal is complete
//      printf("PGF cal complete..\r\n");
            flag=0;
            break;
        }
    }
    if (flag)
    {
    	printf("PGF CAL ERROR\r\n");
        result = DWT_ERROR;
    }

    // Put into normal mode
    dwt_write8bitoffsetreg(RX_CAL_CFG_ID, 0x0, 0);
    dwt_write8bitoffsetreg(RX_CAL_STS_ID, 0x0, 1); //clear the status
    dwt_or8bitoffsetreg(RX_CAL_CFG_ID, 0x2, 0x1); //enable reading
    val = dwt_read32bitoffsetreg(RX_CAL_RESI_ID, 0x0);
    if (val == ERR_RX_CAL_FAIL)
    {
        //PGF I Cal Fail
    	printf("PGF I CAL ERROR\r\n");
        result = DWT_ERROR;
    }
    val = dwt_read32bitoffsetreg(RX_CAL_RESQ_ID, 0x0);
    if (val == ERR_RX_CAL_FAIL)
    {
        //PGF Q Cal Fail
    	printf("PGF Q CAL ERROR\r\n");
        result = DWT_ERROR;
    }

    return result;
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief This function provides the main API for the configuration of the
 * DW3000 and this low-level driver.  The input is a pointer to the data structure
 * of type dwt_config_t that holds all the configurable items.
 * The dwt_config_t structure shows which ones are supported
 *
 * input parameters
 * @param config    -   pointer to the configuration structure, which contains the device configuration data.
 *
 * return DWT_SUCCESS or DWT_ERROR
 * Note: If the RX calibration routine fails the device receiver performance will be severely affected,
 * the application should reset device and try again
 *
 */
int dwt_configure(dwt_config_t *config) {
  uint8_t  chan = config->chan,cnt,flag;
  uint32_t temp;
  uint8_t  scp = ((config->rxCode > 24) || (config->txCode > 24)) ? 1 : 0;
  uint8_t  mode = (config->phrMode == DWT_PHRMODE_EXT) ? SYS_CFG_PHR_MODE_BIT_MASK : 0;
  uint16_t sts_len;
  int      error = DWT_SUCCESS;

#ifdef DWT_API_ERROR_CHECK
  assert((config->dataRate == DWT_BR_6M8) || (config->dataRate == DWT_BR_850K));
  assert(config->rxPAC <= DWT_PAC4);
  assert((chan == 5) || (chan == 9));
  assert((config->txPreambLength == DWT_PLEN_32) || (config->txPreambLength == DWT_PLEN_64) || (config->txPreambLength == DWT_PLEN_72) || (config->txPreambLength == DWT_PLEN_128) || (config->txPreambLength == DWT_PLEN_256)
          || (config->txPreambLength == DWT_PLEN_512) || (config->txPreambLength == DWT_PLEN_1024) || (config->txPreambLength == DWT_PLEN_1536)
          || (config->txPreambLength == DWT_PLEN_2048) || (config->txPreambLength == DWT_PLEN_4096));
  assert((config->phrMode == DWT_PHRMODE_STD) || (config->phrMode == DWT_PHRMODE_EXT));
  assert((config->phrRate == DWT_PHRRATE_STD) || (config->phrRate == DWT_PHRRATE_DTA));
  assert((config->pdoaMode == DWT_PDOA_M0) || (config->pdoaMode == DWT_PDOA_M1) || (config->pdoaMode == DWT_PDOA_M3));
  assert(((config->stsMode & DWT_STS_CONFIG_MASK) == DWT_STS_MODE_OFF)
      || ((config->stsMode & DWT_STS_CONFIG_MASK) == DWT_STS_MODE_1)
      || ((config->stsMode & DWT_STS_CONFIG_MASK) == DWT_STS_MODE_2)
      || ((config->stsMode & DWT_STS_CONFIG_MASK) == DWT_STS_MODE_ND)
      || ((config->stsMode & DWT_STS_CONFIG_MASK) == DWT_STS_MODE_SDC)
      || ((config->stsMode & DWT_STS_CONFIG_MASK) == (DWT_STS_MODE_1 | DWT_STS_MODE_SDC))
      || ((config->stsMode & DWT_STS_CONFIG_MASK) == (DWT_STS_MODE_2 | DWT_STS_MODE_SDC))
      || ((config->stsMode & DWT_STS_CONFIG_MASK) == (DWT_STS_MODE_ND | DWT_STS_MODE_SDC))
      || ((config->stsMode & DWT_STS_CONFIG_MASK) == DWT_STS_CONFIG_MASK));
#endif
  int preamble_len;

  switch (config->txPreambLength) {
    case DWT_PLEN_32:
      preamble_len = 32;
      break;
    case DWT_PLEN_64:
      preamble_len = 64;
      break;
    case DWT_PLEN_72:
      preamble_len = 72;
      break;
    case DWT_PLEN_128:
      preamble_len = 128;
      break;
    default:
      preamble_len = 256;
      break;
  }

  pdw3000local->sleep_mode &= (~(DWT_ALT_OPS | DWT_SEL_OPS3));  //clear the sleep mode ALT_OPS bit
  pdw3000local->longFrames = config->phrMode ;
  sts_len=GET_STS_REG_SET_VALUE((uint16_t)(config->stsLength));
  pdw3000local->ststhreshold = (int16_t)((((uint32_t)sts_len) * 8) * STSQUAL_THRESH_64);
  pdw3000local->stsconfig = config->stsMode;

  /////////////////////////////////////////////////////////////////////////
  //SYS_CFG
  //clear the PHR Mode, PHR Rate, STS Protocol, SDC, PDOA Mode,
  //then set the relevant bits according to configuration of the PHR Mode, PHR Rate, STS Protocol, SDC, PDOA Mode,
  dwt_modify32bitoffsetreg(SYS_CFG_ID, 0, ~(SYS_CFG_PHR_MODE_BIT_MASK | SYS_CFG_PHR_6M8_BIT_MASK | SYS_CFG_CP_SPC_BIT_MASK | SYS_CFG_PDOA_MODE_BIT_MASK | SYS_CFG_CP_SDC_BIT_MASK),
    ((uint32_t)config->pdoaMode) << SYS_CFG_PDOA_MODE_BIT_OFFSET
    | ((uint16_t)config->stsMode & DWT_STS_CONFIG_MASK) << SYS_CFG_CP_SPC_BIT_OFFSET
    | (SYS_CFG_PHR_6M8_BIT_MASK & ((uint32_t)config->phrRate << SYS_CFG_PHR_6M8_BIT_OFFSET))
    | mode);

  if (scp) {
    //configure OPS tables for SCP mode
    pdw3000local->sleep_mode |= DWT_ALT_OPS | DWT_SEL_OPS1;  //configure correct OPS table is kicked on wakeup
    dwt_modify32bitoffsetreg(OTP_CFG_ID, 0, ~(OTP_CFG_OPS_ID_BIT_MASK), DWT_OPSET_SCP | OTP_CFG_OPS_KICK_BIT_MASK);

    dwt_write32bitoffsetreg(IP_CONFIG_LO_ID, 0, IP_CONFIG_LO_SCP);       //Set this if Ipatov analysis is used in SCP mode
    dwt_write32bitoffsetreg(IP_CONFIG_HI_ID, 0, IP_CONFIG_HI_SCP);

    dwt_write32bitoffsetreg(STS_CONFIG_LO_ID, 0, STS_CONFIG_LO_SCP);
    dwt_write8bitoffsetreg(STS_CONFIG_HI_ID, 0, STS_CONFIG_HI_SCP);
  }
  else {
    uint16_t sts_mnth;
    if (config->stsMode != DWT_STS_MODE_OFF) {
      //configure CIA STS lower bound
      if ((config->pdoaMode == DWT_PDOA_M1) || (config->pdoaMode == DWT_PDOA_M0)) {
        //In PDOA mode 1, number of accumulated symbols is the whole length of the STS
        sts_mnth=get_sts_mnth(sts_length_factors[(uint8_t)(config->stsLength)], CIA_MANUALLOWERBOUND_TH_64, 3);
      }
      else {
        //In PDOA mode 3 number of accumulated symbols is half of the length of STS symbols
        sts_mnth=get_sts_mnth(sts_length_factors[(uint8_t)(config->stsLength)], CIA_MANUALLOWERBOUND_TH_64, 4);
      }

      preamble_len += (sts_len) * 8;
      dwt_modify16bitoffsetreg(STS_CONFIG_LO_ID, 2, (uint16_t)~(STS_CONFIG_LO_STS_MAN_TH_BIT_MASK >> 16), sts_mnth & 0x7F);
    }

    //configure OPS tables for non-SCP mode
    if (preamble_len >= 256) {
      pdw3000local->sleep_mode |= DWT_ALT_OPS | DWT_SEL_OPS0;
      dwt_modify32bitoffsetreg(OTP_CFG_ID, 0, ~(OTP_CFG_OPS_ID_BIT_MASK), DWT_OPSET_LONG | OTP_CFG_OPS_KICK_BIT_MASK);
    }
    else {
      dwt_modify32bitoffsetreg(OTP_CFG_ID, 0, ~(OTP_CFG_OPS_ID_BIT_MASK), DWT_OPSET_SHORT | OTP_CFG_OPS_KICK_BIT_MASK);
    }
  }

  dwt_modify8bitoffsetreg(DTUNE0_ID, 0, (uint8_t) ~DTUNE0_PRE_PAC_SYM_BIT_MASK, config->rxPAC);
  dwt_write8bitoffsetreg(STS_CFG0_ID, 0, sts_len-1);    /*Starts from 0 that is why -1*/

  if (config->txPreambLength == DWT_PLEN_72) {
    dwt_setplenfine(8); //value 8 sets fine preamble length to 72 symbols - this is needed to set 72 length.
  }
  else {
    dwt_setplenfine(0); //clear the setting in the FINE_PLEN register.
  }

  if((config->stsMode & DWT_STS_MODE_ND) == DWT_STS_MODE_ND) {
    //configure lower preamble detection threshold for no data STS mode
    dwt_write32bitoffsetreg(DTUNE3_ID, 0, PD_THRESH_NO_DATA);
  }
  else {
    //configure default preamble detection threshold for other modes
    dwt_write32bitoffsetreg(DTUNE3_ID, 0, PD_THRESH_DEFAULT);
  }

  /////////////////////////////////////////////////////////////////////////
  //CHAN_CTRL
  temp = dwt_read32bitoffsetreg(CHAN_CTRL_ID, 0);

  temp &= (~(CHAN_CTRL_RX_PCODE_BIT_MASK | CHAN_CTRL_TX_PCODE_BIT_MASK | CHAN_CTRL_SFD_TYPE_BIT_MASK | CHAN_CTRL_RF_CHAN_BIT_MASK));

  if (chan == 9) temp |= CHAN_CTRL_RF_CHAN_BIT_MASK;

  temp |= (CHAN_CTRL_RX_PCODE_BIT_MASK & ((uint32_t)config->rxCode << CHAN_CTRL_RX_PCODE_BIT_OFFSET));
  temp |= (CHAN_CTRL_TX_PCODE_BIT_MASK & ((uint32_t)config->txCode << CHAN_CTRL_TX_PCODE_BIT_OFFSET));
  temp |= (CHAN_CTRL_SFD_TYPE_BIT_MASK & ((uint32_t)config->sfdType << CHAN_CTRL_SFD_TYPE_BIT_OFFSET));

  dwt_write32bitoffsetreg(CHAN_CTRL_ID, 0, temp);

  /////////////////////////////////////////////////////////////////////////
  //TX_FCTRL
  // Set up TX Preamble Size, PRF and Data Rate
  dwt_modify32bitoffsetreg(TX_FCTRL_ID, 0, ~(TX_FCTRL_TXBR_BIT_MASK | TX_FCTRL_TXPSR_BIT_MASK),
                                            ((uint32_t)config->dataRate << TX_FCTRL_TXBR_BIT_OFFSET)
                                            | ((uint32_t) config->txPreambLength) << TX_FCTRL_TXPSR_BIT_OFFSET);

  //DTUNE (SFD timeout)
  // Don't allow 0 - SFD timeout will always be enabled
  if (config->sfdTO == 0) {
    config->sfdTO = DWT_SFDTOC_DEF;
  }

  dwt_write16bitoffsetreg(DTUNE0_ID, 2, config->sfdTO);

  ///////////////////////
  // RF
  if (chan == 9) {
    // Setup TX analog for ch9
    dwt_write32bitoffsetreg(TX_CTRL_HI_ID, 0, RF_TXCTRL_CH9);
    dwt_write16bitoffsetreg(PLL_CFG_ID, 0, RF_PLL_CFG_CH9);
    // Setup RX analog for ch9
    dwt_write32bitoffsetreg(RX_CTRL_HI_ID, 0, RF_RXCTRL_CH9);
  }
  else {
    // Setup TX analog for ch5
    dwt_write32bitoffsetreg(TX_CTRL_HI_ID, 0, RF_TXCTRL_CH5);
    dwt_write16bitoffsetreg(PLL_CFG_ID, 0, RF_PLL_CFG_CH5);
  }

  dwt_write8bitoffsetreg(LDO_RLOAD_ID, 1, LDO_RLOAD_VAL_B1);
  dwt_write8bitoffsetreg(TX_CTRL_LO_ID, 2, RF_TXCTRL_LO_B2);
  dwt_write8bitoffsetreg(PLL_CAL_ID, 0, RF_PLL_CFG_LD);        // Extend the lock delay

  //Verify PLL lock bit is cleared
  dwt_write32bitoffsetreg(SYS_STATUS_ID, 0, SYS_STATUS_CP_LOCK_BIT_MASK);

  ///////////////////////
  // auto cal the PLL and change to IDLE_PLL state
  dwt_setdwstate(DWT_DW_IDLE);

  for (flag = 1, cnt = 0; cnt < MAX_RETRIES_FOR_PLL; cnt++) {
    HAL_Delay(1);

    if ((dwt_read8bitoffsetreg(SYS_STATUS_ID, 0) & SYS_STATUS_CP_LOCK_BIT_MASK)) {//PLL is locked
//        printf("PLL is locked..\r\n");
        flag=0;
        break;
    }
  }
  if (flag) {
    printf("PLL LOCKING ERROR\r\n");
    return  DWT_ERROR;
  }

  if ((config->rxCode >= 9) && (config->rxCode <= 24)) {//only enable DGC for PRF 64
    //load RX LUTs
    /* If the OTP has DGC info programmed into it, do a manual kick from OTP. */
    if (pdw3000local->dgc_otp_set == DWT_DGC_LOAD_FROM_OTP) {
      _dwt_kick_dgc_on_wakeup(chan);
    }
    /* Else we manually program hard-coded values into the DGC registers. */
    else {
      dwt_configmrxlut(chan);
    }
    dwt_modify16bitoffsetreg(DGC_CFG_ID, 0x0, (uint16_t)~DGC_CFG_THR_64_BIT_MASK, DWT_DGC_CFG << DGC_CFG_THR_64_BIT_OFFSET);
  }
  else {
    dwt_and8bitoffsetreg(DGC_CFG_ID, 0x0, (uint8_t)~DGC_CFG_RX_TUNE_EN_BIT_MASK);
  }

  ///////////////////////
  // PGF
  error = dwt_pgf_cal(1);  //if the RX calibration routine fails the device receiver performance will be severely affected, the application should reset and try again

  return error;
} // end dwt_configure()

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief This function disables the automatic sequencing of the tx-blocks for a specific channel.
 *
 * input parameters:
 * @param[in] chan - specifies the operating channel (e.g. 5 or 9)
 *
 * output parameters:
 * None
 *
 * No return value
 */
static void dwt_enable_rftx_blocks(uint32_t channel)
{
    if (channel == SEL_CHANNEL5)
    {
        dwt_or32bitoffsetreg(RF_CTRL_MASK_ID, 0, (RF_ENABLE_TX_SW_EN_BIT_MASK
                | RF_ENABLE_TX_CH5_BIT_MASK | RF_ENABLE_TX_EN_BIT_MASK
                | RF_ENABLE_TX_EN_BUF_BIT_MASK | RF_ENABLE_TX_BIAS_EN_BIT_MASK));
    }
    else if (channel == SEL_CHANNEL9)
    {
        dwt_or32bitoffsetreg(RF_CTRL_MASK_ID, 0, (RF_ENABLE_TX_SW_EN_BIT_MASK
                | RF_ENABLE_TX_EN_BIT_MASK
                | RF_ENABLE_TX_EN_BUF_BIT_MASK | RF_ENABLE_TX_BIAS_EN_BIT_MASK));
    }
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief This function will enable TX LDOs and allow TX blocks to be manually turned on by dwt_enable_rftx_blocks for a given channel
 *
 * input parameters
 * @param[in] channel - specifies the operating channel (e.g. 5 or 9)
 * @param[in] switch_config - specifies whether the switch needs to be configured for TX
 *
 * output parameters
 *
 */
static void dwt_enable_rf_tx(uint32_t channel, uint8_t switch_control) {
  //Turn on TX LDOs
  dwt_or32bitoffsetreg(LDO_CTRL_ID, 0, (LDO_CTRL_LDO_VDDHVTX_VREF_BIT_MASK |
          LDO_CTRL_LDO_VDDHVTX_EN_BIT_MASK));
  dwt_or32bitoffsetreg(LDO_CTRL_ID, 0, (LDO_CTRL_LDO_VDDTX2_VREF_BIT_MASK |
          LDO_CTRL_LDO_VDDTX1_VREF_BIT_MASK |
          LDO_CTRL_LDO_VDDTX2_EN_BIT_MASK |
          LDO_CTRL_LDO_VDDTX1_EN_BIT_MASK));

  //Enable RF blocks for TX (configure RF_ENABLE_ID reg)
  if (channel == SEL_CHANNEL5) {
    dwt_or32bitoffsetreg(RF_ENABLE_ID, 0, (RF_ENABLE_TX_SW_EN_BIT_MASK
        | RF_ENABLE_TX_CH5_BIT_MASK | RF_ENABLE_TX_EN_BIT_MASK
        | RF_ENABLE_TX_EN_BUF_BIT_MASK | RF_ENABLE_TX_BIAS_EN_BIT_MASK));
  } else {
    dwt_or32bitoffsetreg(RF_ENABLE_ID, 0, (RF_ENABLE_TX_SW_EN_BIT_MASK
        | RF_ENABLE_TX_EN_BIT_MASK
        | RF_ENABLE_TX_EN_BUF_BIT_MASK | RF_ENABLE_TX_BIAS_EN_BIT_MASK));
  }

  if (switch_control) {
    //configure the TXRX switch for TX mode
    dwt_write32bitoffsetreg(RF_SWITCH_CTRL_ID, 0x0, TXRXSWITCH_TX);
  }
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief This function will disable TX LDOs and allow TX blocks to be manually turned off by dwt_disable_rftx_blocks
 *
 * input parameters
 * @param[in] switch_config - specifies whether the switch needs to be restored to auto.
 *
 * output parameters
 * None
 *
 */
static void dwt_disable_rf_tx(uint8_t switch_config) {
  //Turn off TX LDOs
  dwt_write32bitoffsetreg(LDO_CTRL_ID, 0, 0x00000000);

  //Disable RF blocks for TX (configure RF_ENABLE_ID reg)
  dwt_write32bitoffsetreg(RF_ENABLE_ID, 0, 0x00000000);

  if (switch_config) {
    //Restore the TXRX switch to auto
    dwt_write32bitoffsetreg(RF_SWITCH_CTRL_ID, 0x0, TXRXSWITCH_AUTO);
  }
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief This function enables the automatic sequencing of the tx-blocks for a specific channel.
 *
 * input parameters:
 * None
 *
 * output parameters:
 * None
 *
 * No return value
 */
static void dwt_disable_rftx_blocks(void) {
  dwt_write32bitoffsetreg(RF_CTRL_MASK_ID, 0, 0x00000000);
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief this function determines the adjusted bandwidth setting (PG_DELAY bitfield setting)
 * of the DW3000. The adjustment is a result of DW3000 internal PG cal routine, given a target count value it will try to
 * find the PG delay which gives the closest count value.
 * Manual sequencing of TX blocks and TX clocks need to be enabled for either channel 5 or 9.
 * This function presumes that the PLL is already in the IDLE state. Please configure the PLL to IDLE
 * state before calling this function, by calling dwt_configure.
 *
 * input parameters:
 * @param target_count - uint16_t - the PG count target to reach in order to correct the bandwidth
 * @param channel - int - The channel to configure for the corrected bandwidth (5 or 9)
 *
 * output parameters:
 * returns: (uint8_t) The setting that was written to the PG_DELAY register (when calibration completed)
 */
uint8_t dwt_calcbandwidthadj(uint16_t target_count, uint8_t channel) {
  // Force system clock to FOSC/4 and TX clocks on and enable RF blocks
  dwt_force_clocks(FORCE_CLK_SYS_TX);
  dwt_enable_rf_tx(channel, 0);
  dwt_enable_rftx_blocks(channel);

  // Write to the PG target before kicking off PG auto-cal with given target value
  dwt_write16bitoffsetreg(PG_CAL_TARGET_ID, 0x0, target_count & PG_CAL_TARGET_TARGET_BIT_MASK);
  // Run PG count cal
  dwt_or8bitoffsetreg(PGC_CTRL_ID, 0x0, (uint8_t)(PGC_CTRL_PGC_START_BIT_MASK | PGC_CTRL_PGC_AUTO_CAL_BIT_MASK));
  // Wait for calibration to complete
  while (dwt_read8bitoffsetreg(PGC_CTRL_ID, 0) & PGC_CTRL_PGC_START_BIT_MASK);

  //Restore clocks to AUTO and turn off TX blocks
  dwt_disable_rftx_blocks();
  dwt_disable_rf_tx(0);
  dwt_force_clocks(FORCE_CLK_AUTO);

  return  (dwt_read8bitoffsetreg(TX_CTRL_HI_ID, 0) & TX_CTRL_HI_TX_PG_DELAY_BIT_MASK);
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief This function provides the API for the configuration of the TX spectrum
 * including the power and pulse generator delay. The input is a pointer to the data structure
 * of type dwt_txconfig_t that holds all the configurable items.
 *
 * input parameters
 * @param config    -   pointer to the txrf configuration structure, which contains the tx rf config data
 *                      If config->PGcount == 0 the PGdelay value will be used, else the PG calibration will run
 * 0x34,       // PG delay.
 * 0xfdfdfdfd, // TX power.
 * 0x0         // PG count
 * output parameters
 *
 * no return value
 */

void dwt_configuretxrf(
  uint8_t   PGdly,
  //TX POWER
  //31:24     TX_CP_PWR
  //23:16     TX_SHR_PWR
  //15:8      TX_PHR_PWR
  //7:0       TX_DATA_PWR
  uint32_t  power,
  uint16_t  PGcount)
{
  if (PGcount == 0) {
    // Configure RF TX PG_DELAY
    dwt_write8bitoffsetreg(TX_CTRL_HI_ID, 0, PGdly);
  }
  else {
    uint8_t channel = 5;
    if (dwt_read8bitoffsetreg(CHAN_CTRL_ID, 0) & 0x1) {
        channel = 9;
    }
    dwt_calcbandwidthadj(PGcount, channel);
  }

  // Configure TX power
  dwt_write32bitreg(TX_POWER_ID, power);
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief This API function writes the supplied TX data into the DW3000's
 * TX buffer.  The input parameters are the data length in bytes and a pointer
 * to those data bytes.
 *
 * input parameters
 * @param txDataLength   - This is the total length of data (in bytes) to write to the tx buffer.
 *                         Note: the size of tx buffer is 1024 bytes.
 *                         The standard PHR mode allows to transmit frames of up to 127 bytes (including 2 byte CRC)
 *                         The extended PHR mode allows to transmit frames of up to 1023 bytes (including 2 byte CRC)
 *                         if > 127 is programmed, DWT_PHRMODE_EXT needs to be set in the phrMode configuration
 *                         see dwt_configure function
 * @param txDataBytes    - Pointer to the userâs buffer containing the data to send.
 * @param txBufferOffset - This specifies an offset in the DW ICâs TX Buffer at which to start writing data.
 *
 * output parameters
 *
 * returns DWT_SUCCESS for success, or DWT_ERROR for error
 */
int dwt_writetxdata(uint16_t txDataLength, uint8_t *txDataBytes, uint16_t txBufferOffset)
{
#ifdef DWT_API_ERROR_CHECK
    assert((pdw3000local->longFrames && (txDataLength <= EXT_FRAME_LEN)) ||\
           (txDataLength <= STD_FRAME_LEN));
    assert((txBufferOffset + txDataLength) < TX_BUFFER_MAX_LEN);
#endif

    if ((txBufferOffset + txDataLength) < TX_BUFFER_MAX_LEN)
    {
        if(txBufferOffset <= REG_DIRECT_OFFSET_MAX_LEN)
        {
            /* Directly write the data to the IC TX buffer */
            dwt_writetodevice(TX_BUFFER_ID, txBufferOffset, txDataLength, txDataBytes);
        }
        else
        {
            /* Program the indirect offset register A for specified offset to TX buffer */
            dwt_write32bitreg(INDIRECT_ADDR_A_ID, (TX_BUFFER_ID >> 16) );
            dwt_write32bitreg(ADDR_OFFSET_A_ID,   txBufferOffset);

            /* Indirectly write the data to the IC TX buffer */
            dwt_writetodevice(INDIRECT_POINTER_A_ID, 0, txDataLength, txDataBytes);
        }
        return DWT_SUCCESS;
    }
    else
        return DWT_ERROR;
} // end dwt_writetxdata()

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief This API function configures the TX frame control register before the transmission of a frame
 *
 * input parameters:
 * @param txFrameLength - this is the length of TX message (including the 2 byte CRC) - max is 1023
 *                              NOTE: standard PHR mode allows up to 127 bytes
 *                              if > 127 is programmed, DWT_PHRMODE_EXT needs to be set in the phrMode configuration
 *                              see dwt_configure function
 * @param txBufferOffset - the offset in the tx buffer to start writing the data
 * @param ranging - 1 if this is a ranging frame, else 0
 *
 * output parameters
 *
 * no return value
 */
void dwt_writetxfctrl(uint16_t txFrameLength, uint16_t txBufferOffset, uint8_t ranging)
{
    uint32_t reg32;
#ifdef DWT_API_ERROR_CHECK
    assert((pdw3000local->longFrames && (txFrameLength <= EXT_FRAME_LEN)) ||\
           (txFrameLength <= STD_FRAME_LEN));
#endif

    //DW3000/3700 - if offset is > 127, 128 needs to be added before data is written, this will be subtracted internally
    //prior to writing the data
    if(txBufferOffset <= 127)
    {
        // Write the frame length to the TX frame control register
        reg32 = txFrameLength | ((uint32_t)(txBufferOffset) << TX_FCTRL_TXB_OFFSET_BIT_OFFSET) | ((uint32_t)ranging << TX_FCTRL_TR_BIT_OFFSET);
        dwt_modify32bitoffsetreg(TX_FCTRL_ID, 0, ~(TX_FCTRL_TXB_OFFSET_BIT_MASK | TX_FCTRL_TR_BIT_MASK | TX_FCTRL_TXFLEN_BIT_MASK), reg32);
    }
    else
    {
        // Write the frame length to the TX frame control register
        reg32 = txFrameLength | ((uint32_t)(txBufferOffset + DWT_TX_BUFF_OFFSET_ADJUST) << TX_FCTRL_TXB_OFFSET_BIT_OFFSET) | ((uint32_t)ranging << TX_FCTRL_TR_BIT_OFFSET);
        dwt_modify32bitoffsetreg(TX_FCTRL_ID, 0, ~(TX_FCTRL_TXB_OFFSET_BIT_MASK | TX_FCTRL_TR_BIT_MASK | TX_FCTRL_TXFLEN_BIT_MASK), reg32);
        reg32 = dwt_read8bitoffsetreg(SAR_CTRL_ID, 0); //DW3000/3700 - need to read this to load the correct TX buffer offset value
    }

} // end dwt_writetxfctrl()

// FZ: stole from DecaWave API
int dwt_readstsquality(int16_t* rxStsQualityIndex) {
  uint16_t preambleCount;

  //read STS preamble count value
  preambleCount = dwt_read16bitoffsetreg(STS_STS_ID, 0) & STS_STS_ACC_QUAL_BIT_MASK; //  dwt_read16bitoffsetreg(CP_PRNG_ID, CP_STS_OFFSET) & CP_ACC_CP_QUAL_MASK;

  if(preambleCount & STS_ACC_CP_QUAL_SIGNTST) {
    preambleCount |= STS_ACC_CP_QUAL_SIGNEXT;
  }

  *rxStsQualityIndex = (int16_t)preambleCount;

  //determine if the STS Rx quality is good or bad (return >=0 for good and < 0 if bad)
  return (int)((int16_t)preambleCount - pdw3000local->ststhreshold);
}

// FZ: stole from DecaWave API
/*! ------------------------------------------------------------------------------------------------------------------
* @brief This is used to read the PDOA result, it is the phase difference between either the Ipatov and STS POA (in PDOA mode 1),
*  or the two STS POAs (in PDOA mode 3), depending on the PDOA mode of operation. (POA - Phase Of Arrival)
* NOTE: To convert to degrees: float pdoa_deg = ((float)pdoa / (1 << 11)) * 180 / M_PI
* input parameters
* output parameters - the PDOA result (signed in [1:-11] radian units)
* no return value
*/
int16_t dwt_readpdoa(void) {
  int16_t  pdoa;

  //check if in double buffer mode and if so which buffer host is currently accessing
  switch (pdw3000local->dblbuffon) {
  case DBL_BUFF_ACCESS_BUFFER_1:
    //!!! Assumes that Indirect pointer register B was already set. This is done in the dwt_setdblrxbuffmode when mode is enabled.
    pdoa = dwt_read16bitoffsetreg(INDIRECT_POINTER_B_ID, BUF1_PDOA-BUF1_RX_FINFO+2) & (CIA_TDOA_1_PDOA_PDOA_BIT_MASK>>16);
    break;
  case DBL_BUFF_ACCESS_BUFFER_0:
    pdoa = dwt_read16bitoffsetreg(BUF0_PDOA, 2) & (CIA_TDOA_1_PDOA_PDOA_BIT_MASK>>16);
    break;
  default:
    pdoa = dwt_read16bitoffsetreg(CIA_TDOA_1_PDOA_ID, 2) & (CIA_TDOA_1_PDOA_PDOA_BIT_MASK>>16); // phase difference of the 2 POAs
    break;
  }

  if (pdoa & B12_SIGN_EXTEND_TEST) pdoa |= B12_SIGN_EXTEND_MASK; //sign extend
  return pdoa;
}
